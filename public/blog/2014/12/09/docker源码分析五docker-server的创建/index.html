<!DOCTYPE html>
<html lang="zh-CN">

  <head>
  <meta charset="utf-8">
  <meta name="robots" content="all,follow">
  <meta name="googlebot" content="index,follow,snippet,archive">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  
  <title>Docker源码分析（五）：Docker Server的创建</title>
  <meta name="author" content="浙大SEL实验室" />
  
  
  
  
  <meta name="keywords" content="Docker">
  
  
  <meta name="description" content="">

  <meta name="generator" content="Hugo 0.74.2" />

  
  <link href='//fonts.googleapis.com/css?family=Roboto:400,100,100italic,300,300italic,500,700,800' rel='stylesheet' type='text/css'>

  
  <link rel="stylesheet" href="//use.fontawesome.com/releases/v5.11.2/css/all.css">
  <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">

  
  <link href="/css/animate.css" rel="stylesheet">

  
  
    <link href="/css/style.default.css" rel="stylesheet" id="theme-stylesheet">
  

  
  <link href="/css/custom.css" rel="stylesheet">

  
  
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
        <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->
  

  
  <link rel="shortcut icon" href="/img/favicon.ico" type="image/x-icon" />
  <link rel="apple-touch-icon" href="/img/apple-touch-icon.png" />

  
  <link href="/css/owl.carousel.css" rel="stylesheet">
  <link href="/css/owl.theme.css" rel="stylesheet">

  
  <link rel="alternate" href="https://Rachel-Shao.github.io/index.xml" type="application/rss+xml" title="浙大SEL实验室">

  
  
  
  
  
  
  <meta property="og:updated_time" content="2014-12-09T13:00:37Z">
  
    
    
    
    <meta property="article:tag" content="Docker">
    
    
    <meta property="article:published_time" content="2014-12-09T13:00:37Z">
    <meta property="article:modified_time" content="2014-12-09T13:00:37Z">
  

  
  <meta name="twitter:card" content="summary">
  
  <meta name="twitter:title" content="Docker源码分析（五）：Docker Server的创建">
  
  <meta name="twitter:description" content="">
  

</head>


  <body>

    <div id="all">

        <header class="navbar-affixed-top" data-spy="affix" data-offset-top="62">
    <div class="navbar navbar-default yamm" role="navigation" id="navbar" style="background-color:white;">    
        <div class="container">
            <div class="navbar-header">
                <a class="navbar-brand home" href="/">
                    <img src="/img/sel.png" alt="Docker源码分析（五）：Docker Server的创建" class="hidden-xs hidden-sm img-responsive">
                    
                    <span class="sr-only">Docker源码分析（五）：Docker Server的创建 - </span>
                </a>
                <div class="navbar-buttons">
                    <button type="button" class="navbar-toggle btn-template-main" data-toggle="collapse" data-target="#navigation">
                      <span class="sr-only"></span>
                        <i class="fas fa-align-justify"></i>
                    </button>
                </div>
            </div>
            

            <div class="navbar-collapse collapse" id="navigation">
                <ul class="nav navbar-nav navbar-right">
                  
                  
                  <li class="dropdown">
                    
                    <a href="/">主页</a>
                    
                  </li>
                  
                  <li class="dropdown">
                    
                    <a href="/blog/">博客</a>
                    
                  </li>

                  <li class="dropdown">
                    
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">社区 <span class="caret"></span></a>
                  <ul class="dropdown-menu">
                    
                      <li><a href="https://www.servicemesher.com/">ServiceMesh社区</a></li>
                    
                      <li><a href="">kubeedge社区</a></li>

                      <li><a href="http://www.icsoft.zju.edu.cn/index.php">浙江大学智能计算与软件中心</a></li>
                    
                  </ul>

                  <li class="dropdown">
                    
                    <a href="/archives/">归档</a>
                    
                  </li>
                  
                  <li class="dropdown">
                    
                    <a href="/contact/">关于</a>
                    
                  </li>
                  
                </li>

                
                

                
                </ul>
            </div>
            

            <div class="collapse clearfix" id="search">    
                <form class="navbar-form" role="search">
                    <div class="input-group">
                        <input type="text" class="form-control" placeholder="Search">
                        <span class="input-group-btn">
                    <button type="submit" class="btn btn-template-main"><i class="fas fa-search"></i></button>
                </span>
                    </div>
                </form>
            </div>
            
        </div>
    </div>

    
</header>




        <div id="heading-breadcrumbs">
    <div class="container">
        <div class="row">
            <div class="col-md-12">
                <h1>Docker源码分析（五）：Docker Server的创建</h1>
            </div>
        </div>
    </div>
</div>


        <div id="content">
            <div class="container">

                <div class="row">

                    

                    <div class="col-md-9" id="blog-post">

                        
                          <p class="text-muted text-uppercase mb-small text-right">
                            
                            
                            2014-12-09
                          </p>
                        

                        <div id="post-content">
                          <p>本文为《Docker源码分析》系列的第五篇——Docker Server的创建。</p>
<!-- raw HTML omitted -->
<h1 id="1-docker-server简介"><strong>1. Docker Server简介</strong></h1>
<p>Docker架构中，Docker Server是Docker Daemon的重要组成部分。Docker Server最主要的功能是：接受用户通过Docker Client发送的请求，并按照相应的路由规则实现路由分发。 同时，Docker Server具备十分优秀的用户友好性，多种通信协议的支持大大降低Docker用户使用Docker的门槛。除此之外，Docker Server设计实现了详尽清晰的API接口，以供Docker用户选择使用。通信安全方面，Docker Server可以提供安全传输层协议（TLS），保证数据的加密传输。并发处理方面，Docker Daemon大量使用了Golang中的goroutine，大大提高了服务端的并发处理能力。 本文为《Docker源码分析》系列的第五篇——Docker Server的创建。</p>
<h1 id="2-docker-server源码分析内容安排"><strong>2. Docker Server源码分析内容安排</strong></h1>
<p>本文将从源码的角度分析Docker Server的创建，分析内容的安排主要如下：</p>
<ol>
<li>“serveapi”这个job的创建并执行流程，代表Docker Server的创建；</li>
<li>“serveapi”这个job的执行流程深入分析；</li>
<li>Docker Server创建Listener并服务API的流程分析。</li>
</ol>
<h1 id="3-docker-server创建流程"><strong>3. Docker Server创建流程</strong></h1>
<p><a href="http://www.sel.zju.edu.cn/?p=158">《Docker源码分析（三）：Docker Daemon启动》</a>主要分析了Docker Daemon的启动，而在mainDaemon()运行的最后环节，实现了创建并运行名为”serveapi”的job。这一环节的作用是：让Docker Daemon提供API访问服务。实质上，这正是实现了Docker架构中Docker Server的创建与运行。 从流程的角度来说，Docker Server的创建并运行，代表了”serveapi”这个job的整个生命周期：创建Job实例job，配置job环境变量，以及最终执行该job。本章分三节具体分析这三个不同的阶段。</p>
<h2 id="31-创建名为serveapi的job"><strong>3.1 创建名为”serveapi”的job</strong></h2>
<p>Job是Docker架构中Engine内部最基本的任务执行单位，故创建Docker Server这一任务的执行也不例外，需要表示为一个可执行的Job。换言之，需要创建Docker Server，则必须创建一个相应的Job。具体的Job创建形式位于<a href="https://github.com/docker/docker/blob/v1.2.0/docker/daemon.go#L66">./docker/docker/daemon.go</a>，如下：</p>
<pre><code>job := eng.Job(&quot;serveapi&quot;, flHosts...)
</code></pre>
<p>以上代码通过Engine实例eng创建一个Job类型的实例job，job名为”serveapi”，同时用flHost的值来初始化job.Args。flHost的作用是：配置Docker Server监听的协议与监听的地址。 需要注意的是，《Docker源码分析（三）：Docker Daemon启动》mainDaemon()具体实现过程中，在加载builtins环节已经向eng对象注册了key为”serveapi”的Handler，而该Handler的value为api.ServeApi。因此，在运行名为”serveapi”的job时，会执行该job的Handler，即api.ServeApi。</p>
<h2 id="32-配置job环境变量"><strong>3.2 配置job环境变量</strong></h2>
<p>创建完Job实例job之后，Docker Daemon为job配置环境参数。在Job实现过程中，为Job配置参数有两种方式：第一，创建Job实例时，用指定参数直接初始化Job的Args属性；第二，创建完Job后，给Job添加指定的环境变量。以下代码则实现了为创建的job配置环境变量：</p>
<pre><code>job.SetenvBool(&quot;Logging&quot;, true)
job.SetenvBool(&quot;EnableCors&quot;, *flEnableCors)
job.Setenv(&quot;Version&quot;, dockerversion.VERSION)
job.Setenv(&quot;SocketGroup&quot;, *flSocketGroup)

job.SetenvBool(&quot;Tls&quot;, *flTls)
job.SetenvBool(&quot;TlsVerify&quot;, *flTlsVerify)
job.Setenv(&quot;TlsCa&quot;, *flCa)
job.Setenv(&quot;TlsCert&quot;, *flCert)
job.Setenv(&quot;TlsKey&quot;, *flKey)
job.SetenvBool(&quot;BufferRequests&quot;, true)
</code></pre>
<p>对于以上配置，环境变量的归纳总结如下表： <a href="http://www.sel.zju.edu.cn/wp-content/uploads/2014/12/2014-12-09-121005-%E7%9A%84%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png"><img src="http://www.sel.zju.edu.cn/wp-content/uploads/2014/12/2014-12-09-121005-%E7%9A%84%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png" alt="2014-12-09 12:10:05 的屏幕截图"></a></p>
<h2 id="33-运行job"><strong>3.3 运行job</strong></h2>
<p>配置完毕job的环境变量，随即执行job的运行函数，具体实现代码如下：</p>
<pre><code>if err := job.Run(); err != nil {
    log.Fatal(err)
}
</code></pre>
<p>在eng对象中已经注册过key为”serveapi”的Handler，故在运行job的时候，执行这个Handler的value值，相应Handler的value为api.ServeApi。至此，名为”serveapi”的job的生命周期已经完备。下文将深入分析job的Handler，api.ServeApi执行细节的具体实现。</p>
<h1 id="4-serveapi运行流程"><strong>4. ServeApi运行流程</strong></h1>
<p>本章将深入分析Docker Server提供API服务的部分，从源码的角度剖析Docker Server的架构设计与实现。 作为一个监听请求、处理请求的服务端，Docker Server首先明确自身需要为多少种通信协议提供服务，在Docker这个C/S模式的架构中，可以使用的协议无外乎三种:TCP协议，Unix Socket形式，以及fd的形式。随后，Docker Server根据协议的不同，分别创建不同的服务端实例。最后，在不同的服务端实例中，创建相应的路由模块，监听模块，以及处理请求的Handler，形成一个完备的server。 ”serveapi”这个job在运行时，将执行api.ServeApi函数。ServeApi的功能是：循环检查所有Docker Daemon当前支持的通信协议，并对于每一种协议都创建一个goroutine，在这个goroutine内部配置一个服务于HTTP请求的server端。ServeApi的代码实现位于<a href="https://github.com/docker/docker/blob/v1.2.0/api/server/server.go#L1339-L1368">./docker/api/server/server.go#L1339</a>： 第一，判断job.Args的长度是否为0，由于通过flHosts来初始化job.Args，故job.Args的长度若为0的话，说明没有Docker Server没有监听的协议与地址，参数有误，返回错误信息。代码如下：</p>
<pre><code>if len(job.Args) == 0 {
    return job.Errorf(&quot;usage: %s PROTO://ADDR [PROTO://ADDR ...]&quot;, job.Name)
}
</code></pre>
<p>第二，定义两个变量，protoAddrs代表flHosts的内容；而chError定义了和protoAddrs长度一致的error类型channel管道，chError的作用在下文中会说明。同时还定义了activationLock，这是一个用来同步”serveapi”和”acceptconnections”这两个job执行的channel。在serveapi运行时ServeFd和ListenAndServe的实现中，由于activationLock这个channel中没有内容而阻塞，而当运行”acceptionconnections”这个job时，会首先通知init进程Docker Daemon已经启动完毕，并关闭activationLock，同时也开启了serveapi的继续执行。正是由于activationLock的存在，保证了”acceptconnections”这个job的运行起到通知”serveapi”开启正式服务于API的效果。代码如下：</p>
<pre><code>var (
    protoAddrs = job.Args
    chErrors   = make(chan error, len(protoAddrs))
)
activationLock = make(chan struct{})
</code></pre>
<p>第三，遍历protoAddrs，即job.Args，将其中的每一项都按照字符串“://”进行分割，若分割后protoAddrParts的长度不为2，则说明协议加地址的书写形式有误，返回job错误；若不为2，则分割获得每一项中的协议protoAddrPart[0]与地址protoAddrParts<a href="http://www.sel.zju.edu.cn/?p=158">1</a>。最后分别创建一个goroutine来执行ListenAndServe的操作。goroutine的运行主要依赖于ListenAndServe(protoAddrParts[0], protoAddrParts<a href="http://www.sel.zju.edu.cn/?p=158">1</a>, job)的运行结果，若返回error，则chErrors中有error，当前goroutine执行完毕；若没有返回error，则该goroutine持续运行，持续提供服务。其中最为重要的是ListenAndServe的实现，该函数具体实现了如何创建listener、router以及server，并协调三者进行工作，最终服务于API请求。代码如下：</p>
<pre><code>for _, protoAddr := range protoAddrs {
    protoAddrParts := strings.SplitN(protoAddr, &quot;://&quot;, 2)
    if len(protoAddrParts) != 2 {
        return job.Errorf(&quot;usage: %s PROTO://ADDR [PROTO://ADDR ...]&quot;, job.Name)
    }
    go func() {
        log.Infof(&quot;Listening for HTTP on %s (%s)&quot;, proto    AddrParts[0], protoAddrParts[1])
        chErrors &lt;- ListenAndServe(protoAddrParts[0], protoAddrParts[1], job)
    }()
}
</code></pre>
<p>第四，根据chErrors的值运行，若chErrors这个channel中有错误内容，则ServeApi该函数返回；若无错误内容，则循环被阻塞。代码如下：</p>
<pre><code>for i := 0; i &lt; len(protoAddrs); i += 1 {
    err := &lt;-chErrors
    if err != nil {
        return job.Error(err)
    }
}
    return engine.StatusOK
</code></pre>
<p>至此， ServeApi的运行流程已经详细分析完毕，其中核心部分ListenAndServe的实现，下一章开始深入。</p>
<h1 id="5-listenandserve实现"><strong>5. ListenAndServe实现</strong></h1>
<p>ListenAndServe的功能是：使Docker Server监听某一指定地址，接受该地址上的请求，并对以上请求路由转发至相应的处理函数Handler处。从实现的角度来看，ListenAndServe主要实现了设置一个服务于HTTP的server，该server将监听指定地址上的请求，并对请求做特定的协议检查，最终完成请求的路由与分发。代码实现位于<a href="https://github.com/docker/docker/blob/v1.2.0/api/server/server.go#L1247-L1335">./docker/api/server/server.go</a>。 ListenAndServe的实现可以分为以下4个部分：</p>
<ol>
<li>创建router路由实例；</li>
<li>创建listener监听实例；</li>
<li>创建http.Server；</li>
<li>启动API服务。</li>
</ol>
<p>ListenAndServe的执行流程如下图： <a href="http://www.sel.zju.edu.cn/wp-content/uploads/2014/12/ListenAndServe.jpg"><img src="http://www.sel.zju.edu.cn/wp-content/uploads/2014/12/ListenAndServe-843x1024.jpg" alt="ListenAndServe"></a></p>
<p>图5.1 ListenAndServer执行流程图</p>
<p>下文将按照ListenAndServe执行流程图一一深入分析各个部分。</p>
<h2 id="51-创建router路由实例"><strong>5.1 创建router路由实例</strong></h2>
<p>首先，ListenAndServe的实现中通过createRouter创建了一个router路由实例。代码实现如下：</p>
<pre><code>r, err := createRouter(job.Eng, job.GetenvBool(&quot;Logging&quot;), job.GetenvBool(&quot;EnableCors&quot;), job.Getenv(&quot;Version&quot;))
if err != nil {
    return err
}
</code></pre>
<p>createRouter的实现位于<a href="https://github.com/docker/docker/blob/v1.2.0/api/server/server.go#L1094-L1171">./docker/api/server/server.go#L1094</a>。 创建router路由实例是一个重要的环节，路由实例的作用是：负责Docker Server对请求进行路由以及分发。实现过程中，主要两个步骤：第一，创建全新的router路由实例；第二，为router实例添加路由记录。</p>
<h3 id="511-创建空路由实例"><strong>5.1.1 创建空路由实例</strong></h3>
<p>实质上，createRouter通过包gorilla/mux实现了一个功能强大的路由器和分发器。如下：</p>
<pre><code>r := mux.NewRouter()
</code></pre>
<p>NewRouter()函数返回了一个全新的router实例r。在创建Router实例时，给Router对象的两个属性进行赋值，这两个属性为nameRoutes和KeepContext。其中namedRoutes属性为一个map类型，其中key为string类型，value为Route路由记录类型；另外，KeepContext属性为false，表示Docker Server在处理完请求之后，就清除请求的内容，不对请求做存储操作。代码位于<a href="https://github.com/docker/docker/blob/v1.2.0/vendor/src/github.com/gorilla/mux/mux.go#L16-L18">./docker/vendor/src/github.com/gorilla/mux/mux.go#L16</a>，如下：</p>
<pre><code>func NewRouter() *Router {
    return &amp;Router{namedRoutes: make(map[string]*Route), KeepContext: false}
}
</code></pre>
<p>可见，以上代码返回的类型为mux.Router。mux.Router会通过一系列已经注册过的路由记录，来为接受的请求做匹配，首先通过请求的URL或者其他条件，找到相应的路由记录，并调用这条路由记录中的执行Handler。mux.Router有以下这些特性：</p>
<ul>
<li>请求可以基于URL 的主机名、路径、路径前缀、shemes、请求头和请求值、HTTP请求方法类型或者使用自定义的匹配规则；</li>
<li>URL主机名和路径可以拥有一个正则表达式来表示；</li>
<li>注册的URL可以被直接运用，也可以被保留，这样可以保证维护资源的使用；</li>
<li>路由记录可以被用以子路由器：如果父路由记录匹配，则嵌套记录只会被用来测试。当设计一个组内的路由记录共享相同的匹配条件时，如主机名、路劲前缀或者其他重复的属性，子路由的方式很有帮助</li>
<li>mux.Router实现了http.Handler接口，故和标准的http.ServeMux兼容。</li>
</ul>
<h3 id="512-添加路由记录"><strong>5.1.2 添加路由记录</strong></h3>
<p>Router路由实例r创建完毕，下一步工作是为Router实例r添加所需要的路由记录。路由记录存储着用来匹配请求的信息，包括对请求的匹配规则，以及匹配之后的Handler执行入口。 回到<a href="https://github.com/docker/docker/blob/v1.2.0/api/server/server.go#L1094-L1171">createRouter</a>实现代码中，首先判断Docker Daemon的启动过程中有没有开启DEBUG模式。通过docker可执行文件启动Docker Daemon，解析flag参数时，若flDebug的值为false，则说明不需要配置DEBUG环境；若flDebug的值为true，则说明需要为Docker Daemon添加DEBUG功能。具体的代码实现如下：</p>
<pre><code>if os.Getenv(&quot;DEBUG&quot;) != &quot;&quot; {
    AttachProfiler(r)
}
</code></pre>
<p>AttachProiler(r)的功能是为路由实例r添加与DEBUG相关的路由记录，具体实现位于<a href="https://github.com/docker/docker/blob/v1.2.0/api/server/server.go#L1083-L1092">./docker/api/server/server.go#L1083</a>，如下：</p>
<pre><code>func AttachProfiler(router *mux.Router) {
    router.HandleFunc(&quot;/debug/vars&quot;, expvarHandler)
    router.HandleFunc(&quot;/debug/pprof/&quot;, pprof.Index)
    router.HandleFunc(&quot;/debug/pprof/cmdline&quot;, pprof.Cmdline)
    router.HandleFunc(&quot;/debug/pprof/profile&quot;, pprof.Profile)
    router.HandleFunc(&quot;/debug/pprof/symbol&quot;, pprof.Symbol)
    router.HandleFunc(&quot;/debug/pprof/heap&quot;, pprof.Handler(&quot;heap&quot;).ServeHTTP)
    router.HandleFunc(&quot;/debug/pprof/goroutine&quot;, pprof.Handler(&quot;goroutine&quot;).ServeHTTP)
    router.HandleFunc(&quot;/debug/pprof/threadcreate&quot;, pprof.Handler(&quot;threadcreate&quot;).ServeHTTP)
}
</code></pre>
<p>分析以上源码，可以发现Docker Server使用两个包来完成DEBUG相关的工作：expvar和pprof。包expvar为公有变量提供标准化的接口，使得这些公有变量可以通过HTTP的形式在”/debug/vars”这个URL下被访问，传输时格式为JSON。包pprof将Docker Server运行时的分析数据通过”/debug/pprof/”这个URL向外暴露。这些运行时信息包括以下内容：可得的信息列表、正在运行的命令行信息、CPU信息、程序函数引用信息、ServeHTTP这个函数三部分信息使用情况（堆使用、goroutine使用和thread使用）。 回到<a href="https://github.com/docker/docker/blob/v1.2.0/api/server/server.go#L1094-L1171">createRouter函数实现</a>中，完成DEBUG功能的所有工作之后，Docker Docker创建了一个map类型的对象m，用于初始化路由实例r的路由记录。简化的m对象，代码如下：</p>
<pre><code>m := map[string]map[string]HttpApiFunc{
    &quot;GET&quot;: {
        ……
        &quot;/images/{name:.*}/get&quot;:           getImagesGet,
        ……
    },
    &quot;POST&quot;: {
        ……
        &quot;/containers/{name:.*}/copy&quot;:    postContainersCopy,
    },
    &quot;DELETE&quot;: {
        &quot;/containers/{name:.*}&quot;: deleteContainers,
        &quot;/images/{name:.*}&quot;:     deleteImages,
    },
    &quot;OPTIONS&quot;: {
        &quot;&quot;: optionsHandler,
    },
}
</code></pre>
<p>对象m的类型为map，其中key为string类型，代表HTTP的请求类型，如”GET”，”POST”，”DELETE”等，value为另一个map类型，该map代表的是URL与执行Handler的映射。在第二个map类型中，key为string类型，代表是的请求URL，value为HttpApiFunc类型，代表具体的执行Handler。其中HttpApiFunc类型的定义如下：</p>
<pre><code>type HttpApiFunc func(eng *engine.Engine, version version.Version, w http.ResponseWriter, r *http.Request, vars map[string]string) error
</code></pre>
<p>完成对象m的定义，随后Docker Server通过该对象m来添加路由实例r的路由记录。对象m的请求方法，请求URL和请求处理Handler这三样内容可以为对象r构建一条路由记录。实现代码。如下：</p>
<pre><code>for method, routes := range m {
    for route, fct := range routes {
        log.Debugf(&quot;Registering %s, %s&quot;, method, route)
        localRoute := route
        localFct := fct
        localMethod := method

        f := makeHttpHandler(eng, logging, localMethod, localRoute, localFct, enableCors, version.Version(dockerVersion))

        if localRoute == &quot;&quot; {
            r.Methods(localMethod).HandlerFunc(f)
        } else {
            r.Path(&quot;/v{version:[0-9.]+}&quot; + localRoute).Methods(localMethod).HandlerFunc(f)
         r.Path(localRoute).Methods(localMethod).HandlerFunc(f)
        }
    }
}
</code></pre>
<p>以上代码，在第一层循环中，按HTTP请求方法划分，获得请求方法各自的路由记录，第二层循环，按匹配请求的URL进行划分，获得与URL相对应的执行Handler。在嵌套循环中，通过makeHttpHandler返回一个执行的函数f。在返回的这个函数中，涉及了logging信息，CORS信息（跨域资源共享协议），以及版本信息。以下举例说明makeHttpHandler的实现，从对象m可以看到，对于”GET”请求，请求URL为”/info”，则请求Handler为”getInfo”。执行makeHttpHandler的具体代码实现如下：</p>
<pre><code>func makeHttpHandler(eng *engine.Engine, logging bool, localMethod string, localRoute string, handlerFunc HttpApiFunc, enableCors bool, dockerVersion version.Version) http.HandlerFunc {
    return func(w http.ResponseWriter, r *http.Request) {
        // log the request
        log.Debugf(&quot;Calling %s %s&quot;, localMethod, localRoute)

        if logging {
            log.Infof(&quot;%s %s&quot;, r.Method, r.RequestURI)
        }

        if strings.Contains(r.Header.Get(&quot;User-Agent&quot;), &quot;Docker-Client/&quot;) {
            userAgent := strings.Split(r.Header.Get(&quot;User-Agent&quot;), &quot;/&quot;)
            if len(userAgent) == 2 &amp;&amp; !dockerVersion.Equal(version.Version(userAgent[1])) {
                log.Debugf(&quot;Warning: client and server don't have the same version (client: %s, server: %s)&quot;, userAgent[1], dockerVersion)
            }
        }
        version := version.Version(mux.Vars(r)[&quot;version&quot;])
        if version == &quot;&quot; {
            version = api.APIVERSION
        }
        if enableCors {
            writeCorsHeaders(w, r)
        }

        if version.GreaterThan(api.APIVERSION) {
            http.Error(w, fmt.Errorf(&quot;client and server don't have same version (client : %s, server: %s)&quot;, version, api.APIVERSION).Error(), http.StatusNotFound)
            return
        }

        if err := handlerFunc(eng, version, w, r, mux.Vars(r)); err != nil {
            log.Errorf(&quot;Handler for %s %s returned error: %s&quot;, localMethod, localRoute, err)
            httpError(w, err)
        }
    }
}
</code></pre>
<p>可见makeHttpHandler的执行直接返回一个函数func(w http.ResponseWriter, r *http.Request) 。在这个func函数的实现中，判断makeHttpHandler传入的logging参数，若为true，则将该Handler的执行通过日志显示，另外通过makeHttpHandler传入的enableCors参数判断是否在HTTP请求的头文件中添加跨域资源共享信息，若为true，则通过writeCorsHeaders函数向response中添加有关CORS的HTTP Header，代码实现位于<a href="https://github.com/docker/docker/blob/v1.2.0/api/server/server.go#L1022-L1026">./docker/api/server/server.go#L1022</a>，如下：</p>
<pre><code>func writeCorsHeaders(w http.ResponseWriter, r *http.Request) {
    w.Header().Add(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;)
    w.Header().Add(&quot;Access-Control-Allow-Headers&quot;, &quot;Origin, X-Requested-With, Content-Type, Accept&quot;)
    w.Header().Add(&quot;Access-Control-Allow-Methods&quot;, &quot;GET, POST, DELETE, PUT, OPTIONS&quot;)
}
</code></pre>
<p>最为重要的执行部分位于handlerFunc(eng, version, w, r, mux.Vars(r))，如以下代码：</p>
<pre><code>if err := handlerFunc(eng, version, w, r, mux.Vars(r)); err != nil {
    log.Errorf(&quot;Handler for %s %s returned error: %s&quot;, localMethod, localRoute, err)
    httpError(w, err)
}
</code></pre>
<p>对于”GET”请求类型，”/info”请求URL的请求，由于Handler名为getInfo，也就是说handlerFunc这个形参的值为getInfo，故执行部分直接运行getInfo(eng, version, w, r, mux.Vars(r))，而getInfo的具体实现位于<a href="https://github.com/docker/docker/blob/v1.2.0/api/server/server.go#L269-L273">./docker/api/server/serve.go#L269</a>，如下：</p>
<pre><code>func getInfo(eng *engine.Engine, version version.Version, w http.ResponseWriter, r *http.Request, vars map[string]string) error {
    w.Header().Set(&quot;Content-Type&quot;, &quot;application/json&quot;)
    eng.ServeHTTP(w, r)
    return nil
}
</code></pre>
<p>以上makeHttpHandler的执行已经完毕，返回func函数，作为指定URL对应的执行Handler。 创建完处理函数Handler，需要向路由实例中添加新的路由记录。如果URL信息为空，则直接为该HTTP请求方法类型添加路由记录；若URL不为空，则为请求URL路径添加新的路由记录。需要额外注意的是，在URL不为空，为路由实例r添加路由记录时，考虑了API版本的问题，通过r.Path(&quot;/v{version:[0-9.]+}&rdquo; + localRoute).Methods(localMethod).HandlerFunc(f)来实现。 至此，mux.Router实例r的两部分工作工作已经全部完成：创建空的路由实例r，为r添加相应的路由记录，最后返回路由实例r。</p>
<h2 id="52-创建listener监听实例"><strong>5.2 创建listener监听实例</strong></h2>
<p>路由模块，完成了请求的路由与分发这一重要部分，属于<a href="https://github.com/docker/docker/blob/v1.2.0/api/server/server.go#L1247-L1335">ListenAndServe实现</a>中的第一个重要工作。对于请求的监听功能，同样需要模块来完成。而在<a href="https://github.com/docker/docker/blob/v1.2.0/api/server/server.go#L1247-L1335">ListenAndServe实现</a>中，第二个重要的工作就是创建Listener。Listener是一种面向流协议的通用网络监听模块。 在创建Listener之前，先判断Docker Server允许的协议，若协议为fd形式，则直接通过ServeFd来服务请求；若协议不为fd形式，则继续往下执行。 在程序执行过程中，需要判断”serveapi”这个job的环境中”BufferRequests”的值，是否为真，若为真，则通过包listenbuffer创建一个Listener的实例l，否则的话直接通过包net创建Listener实例l。具体的代码位于<a href="https://github.com/docker/docker/blob/v1.2.0/api/server/server.go#L1269-L1273">./docker/api/server/server.go#L1269</a>，如下：</p>
<pre><code>if job.GetenvBool(&quot;BufferRequests&quot;) {
    l, err = listenbuffer.NewListenBuffer(proto, addr, activationLock)
} else {
    l, err = net.Listen(proto, addr)
}
</code></pre>
<p>由于在mainDaemon()中创建”serveapi”这个job之后，给job添加环境变量时，已经给”BufferRequets”赋值为true，故使用包listenbuffer创建listener实例。 Listenbuffer的作用是：让Docker Server可以立即监听指定协议地址上的请求，但是将这些请求暂时先缓存下来，等Docker Daemon全部启动完毕之后，才让Docker Server开始接受这些请求。这样设计有一个很大的好处，那就是可以保证在Docker Daemon还没有完全启动完毕之前，接收并缓存尽可能多的用户请求。 若协议的类型为TCP，另外job中环境变量Tls或者TlsVerify有一个为真，则说明Docker Server需要支持HTTPS服务，需要为Docker Server配置安全传输层协议（TLS）的支持。为实现TLS协议，首先需要建立一个tls.Config类型实例tlsConfig，然后在tlsConfig中加载证书，认证信息等，最终通过包tls中的NewListener函数，创建出适应于接收HTTPS协议请求的Listener实例l，代码如下：</p>
<pre><code>l = tls.NewListener(l, tlsConfig)
</code></pre>
<p>至此，创建网络监听的Listener部分已经全部完成。</p>
<h2 id="53-创建httpserver"><strong>5.3 创建http.Server</strong></h2>
<p>Docker Server同样需要创建一个Server对象来运行HTTP服务端。在<a href="https://github.com/docker/docker/blob/v1.2.0/api/server/server.go#L1247-L1335">ListenAndServe实现</a>中第三个重要的工作就是创建http.Server：</p>
<pre><code>httpSrv := http.Server{Addr: addr, Handler: r}
</code></pre>
<p>其中addr为需要监听的地址，r为mux.Router路由实例。</p>
<h2 id="54-启动api服务"><strong>5.4 启动API服务</strong></h2>
<p>创建http.Server实例之后，Docker Server立即启动API服务，使Docker Server开始在Listener监听实例l上接受请求，并对于每一个请求都生成一个新的goroutine来做专属服务。对于每一个请求，goroutine会读取请求，查询路由表中的路由记录项，找到匹配的路由记录，最终调用路由记录中的执行Handler，执行完毕后，goroutine对请求返回响应信息。代码如下：</p>
<pre><code>return httpSrv.Serve(l)
</code></pre>
<p>至此，ListenAndServer的所有流程已经分析完毕，Docker Server已经开始针对不同的协议，服务API请求。</p>
<h1 id="6-总结"><strong>6. 总结</strong></h1>
<p>Docker Server作为Docker Daemon架构中请求的入口，接管了所有Docker Daemon对外的通信。通信API的规范性，通信过程的安全性，服务请求的并发能力，往往都是Docker用户最为关心的内容。本文基于源码，分析了Docker Server大部分的细节实现。希望Docker用户可以初探Docker Server的设计理念，并且可以更好的利用Docker Server创造更大的价值。</p>
<h1 id="7-参考文献"><strong>7. 参考文献</strong></h1>
<ol>
<li><a href="http://guzalexander.com/2013/12/06/golang-channels-tutorial.html">Golang channels tutorial</a></li>
<li><a href="http://www.gorillatoolkit.org/pkg/mux">Package mux</a></li>
<li><a href="http://docs.studygolang.com/pkg/expvar/">Package expvar</a></li>
<li><a href="http://docs.studygolang.com/pkg/net/http/pprof/">Package pprof</a></li>
</ol>
<p>[simple-author-box]</p>

                        </div>
                        
                        
                        
                        
                        
                        <div id="SOHUCS"></div>
                        <script charset="utf-8" type="text/javascript" src="https://cy-cdn.kuaizhan.com/upload/changyan.js" ></script>
                        <script type="text/javascript">
                          window.changyan.api.config({
                          appid: 'cyuX8hDAj',
                          conf: 'prod_4e1f40d37469ca7d81688963c063f0f7'
                          });
                        </script>

                    </div>
                    

                    

                    

                    <div class="col-md-3">

                        

                        

<div class="panel panel-default sidebar-menu">

    <div class="panel-heading">
      <h3 class="panel-title">搜索栏</h3>
      
    </div>

    <div class="panel-body">
        
        <div class="search" id="search">
            <div class="input-group">
                <input type="text" name="q" class="form-control" placeholder="请输入文章标题或摘要..." id="search-key">
                <input type="hidden" name="sitesearch" value="https://Rachel-Shao.github.io/">
                <span class="input-group-btn">
                    <button type="submit" class="btn btn-template-main" onclick="search()"><i class="fas fa-search"></i></button>
                </span>
            </div>
            <h1 id="search-tip" style="color: red;text-align: center;display: none;font-size: medium;">搜索中，请稍后 ...</h1>
        </div>
        <script type="text/javascript">
            
            window.onload = function() {
                      document.onkeydown = function(ev) {
                        var event = ev || event
                        if (event.keyCode == 13) {
                          search()
                        }
                      }
                    }
            
            function search() {
                      key = document.getElementById("search-key").value;
                      if (key === "") {
                        
                        return;
                      }
                      document.getElementById("search-key").value = "";
                  
                      
                      document.getElementById("search-tip").innerText = "搜索中，请稍后 ...";
                      document.getElementById("search-tip").style.display = "block";
                  
                      
                      var el = document.getElementById('blog-listing-medium');
                      var childs = el.childNodes;
                      for (var i = childs.length - 1; i >= 0; i--) {
                        el.removeChild(childs[i]);
                      }
                  
                      
                      xmltext = new XMLHttpRequest;
                      xmltext.open("GET", "/index.xml", false);
                      xmltext.send();
                      resp = xmltext.responseXML;
                      items = resp.getElementsByTagName("item");
                      
                      var i = 0;
                      haveResult = false;
                      while (i < items.length) {
                        txt = items[i].getElementsByTagName("title")[0].innerHTML + items[i].getElementsByTagName("description")[0].innerHTML
                        if (txt.indexOf(key) > -1) {
                          haveResult = true;
                          title = items[i].getElementsByTagName("title")[0].innerHTML;
                          link = items[i].getElementsByTagName("link")[0].innerHTML;
                          time = items[i].getElementsByTagName("pubDate")[0].innerHTML;
                          mark = items[i].getElementsByTagName("description")[0].innerHTML;
                          addItem(title, link, time, mark)
                        }
                        i++;
                      }
                      if (!haveResult) {
                        document.getElementById("search-tip").innerText = "搜索完毕，未发现结果 ...";
                        document.getElementById("search-tip").style.display = "block";
                      }
                    }
                  
                    
                    function addItem(title, link, time, mark) {
                      document.getElementById("search-tip").style.display = "none";
                      tmpl = "<article class=\"post\" style=\"border-bottom: 1px solid #e6e6e6;\" >" +
                        "<header class=\"post-header\">" +
                        "<h1 class=\"post-title\"><a class=\"post-link\" href=\"" + link + "\" target=\"_blank\">" + title + "</a></h1>" +
                        "<div class=\"post-meta\">" +
                        " <span class=\"post-time\">" + time + "</span>" +
                        "</div>" +
                        " </header>" +
                        "<div class=\"post-content\">" +
                        "<div class=\"post-summary\">" + mark + "</div>" +
                        "<div class=\"read-more\">" +
                        "<a href=" + link + " class=\"read-more-link\" target=\"_blank\">阅读更多</a>" +
                        "</div>" +
                        " </div>" +
                        "</article>"
                      div = document.createElement("div")
                      div.innerHTML = tmpl;
                      document.getElementById('blog-listing-medium').appendChild(div)
                    }

        </script>
        
    </div>
</div>







<div class="panel panel-default sidebar-menu">

    <div class="panel-heading">
        <h3 class="panel-title">归档栏</h3>
        
    </div>

    <div class="panel-body">
        <ul class="nav nav-pills nav-stacked">
            
            
            <li>
                <a href="/categories/cloudfoundry">cloudfoundry (12)</a>
            </li>
            
            <li>
                <a href="/categories/contaienrd">contaienrd (1)</a>
            </li>
            
            <li>
                <a href="/categories/docker">docker (12)</a>
            </li>
            
            <li>
                <a href="/categories/kubernetes">kubernetes (1)</a>
            </li>
            
            <li>
                <a href="/categories/network">network (1)</a>
            </li>
            
        </ul>
    </div>

</div>








<div class="panel sidebar-menu">

    <div class="panel-heading">
        <h3 class="panel-title">标签栏</h3>
        
    </div>

    <div class="panel-body">
        <ul class="tag-cloud">
            
            
            <li>
                <a href="/tags/agent"><i class="fas fa-tags"></i> agent</a>
            </li>
            
            <li>
                <a href="/tags/apiserver"><i class="fas fa-tags"></i> apiserver</a>
            </li>
            
            <li>
                <a href="/tags/books"><i class="fas fa-tags"></i> books</a>
            </li>
            
            <li>
                <a href="/tags/bosh"><i class="fas fa-tags"></i> bosh</a>
            </li>
            
            <li>
                <a href="/tags/ccng"><i class="fas fa-tags"></i> ccng</a>
            </li>
            
            <li>
                <a href="/tags/cf-release"><i class="fas fa-tags"></i> cf-release</a>
            </li>
            
            <li>
                <a href="/tags/cgroups"><i class="fas fa-tags"></i> cgroups</a>
            </li>
            
            <li>
                <a href="/tags/cloud_controller_ng"><i class="fas fa-tags"></i> cloud_controller_ng</a>
            </li>
            
            <li>
                <a href="/tags/cloudfoundry"><i class="fas fa-tags"></i> cloudfoundry</a>
            </li>
            
            <li>
                <a href="/tags/cloudnative"><i class="fas fa-tags"></i> cloudnative</a>
            </li>
            
            <li>
                <a href="/tags/collector"><i class="fas fa-tags"></i> collector</a>
            </li>
            
            <li>
                <a href="/tags/containerd"><i class="fas fa-tags"></i> containerd</a>
            </li>
            
            <li>
                <a href="/tags/cri"><i class="fas fa-tags"></i> cri</a>
            </li>
            
            <li>
                <a href="/tags/dea"><i class="fas fa-tags"></i> dea</a>
            </li>
            
            <li>
                <a href="/tags/docker"><i class="fas fa-tags"></i> docker</a>
            </li>
            
            <li>
                <a href="/tags/docker-network"><i class="fas fa-tags"></i> docker-network</a>
            </li>
            
            <li>
                <a href="/tags/edgecomputing"><i class="fas fa-tags"></i> edgecomputing</a>
            </li>
            
            <li>
                <a href="/tags/etcd"><i class="fas fa-tags"></i> etcd</a>
            </li>
            
            <li>
                <a href="/tags/gorouter"><i class="fas fa-tags"></i> gorouter</a>
            </li>
            
            <li>
                <a href="/tags/haproxy"><i class="fas fa-tags"></i> haproxy</a>
            </li>
            
            <li>
                <a href="/tags/healthmanager"><i class="fas fa-tags"></i> healthmanager</a>
            </li>
            
            <li>
                <a href="/tags/istio"><i class="fas fa-tags"></i> istio</a>
            </li>
            
            <li>
                <a href="/tags/kubeedge"><i class="fas fa-tags"></i> kubeedge</a>
            </li>
            
            <li>
                <a href="/tags/kubelet"><i class="fas fa-tags"></i> kubelet</a>
            </li>
            
            <li>
                <a href="/tags/kubernetes"><i class="fas fa-tags"></i> kubernetes</a>
            </li>
            
            <li>
                <a href="/tags/libcontainer"><i class="fas fa-tags"></i> libcontainer</a>
            </li>
            
            <li>
                <a href="/tags/micro-service"><i class="fas fa-tags"></i> micro-service</a>
            </li>
            
            <li>
                <a href="/tags/namespace"><i class="fas fa-tags"></i> namespace</a>
            </li>
            
            <li>
                <a href="/tags/nats"><i class="fas fa-tags"></i> nats</a>
            </li>
            
            <li>
                <a href="/tags/news"><i class="fas fa-tags"></i> news</a>
            </li>
            
            <li>
                <a href="/tags/pipework"><i class="fas fa-tags"></i> pipework</a>
            </li>
            
            <li>
                <a href="/tags/pouch"><i class="fas fa-tags"></i> pouch</a>
            </li>
            
            <li>
                <a href="/tags/runc"><i class="fas fa-tags"></i> runc</a>
            </li>
            
            <li>
                <a href="/tags/runtime"><i class="fas fa-tags"></i> runtime</a>
            </li>
            
            <li>
                <a href="/tags/security"><i class="fas fa-tags"></i> security</a>
            </li>
            
            <li>
                <a href="/tags/serverless"><i class="fas fa-tags"></i> serverless</a>
            </li>
            
            <li>
                <a href="/tags/service-mesh"><i class="fas fa-tags"></i> service-mesh</a>
            </li>
            
            <li>
                <a href="/tags/syslog_aggregator"><i class="fas fa-tags"></i> syslog_aggregator</a>
            </li>
            
        </ul>
    </div>

</div>






                        

                    </div>
                    

                    

                </div>
                

            </div>
            
        </div>
        

        <footer id="footer">
    <div class="container">

        
        <div class="col-md-4 col-sm-6">
            <h4></h4>

            <p><strong>关于我们：<strong> <p>浙大SEL实验室</p><p>地址：杭州市浙大路38号曹光彪西楼405室</p><p><strong></strong>
            <a href="/contact" class="btn btn-small btn-template-main" >跳转到关于</a>

            <hr class="hidden-md hidden-lg hidden-sm">

        </div>
        
        

        <div class="col-md-4 col-sm-6">

             
            <h4>最新博客</h4>
            

            <div class="blog-entries">
                
                <div class="item same-height-row clearfix">
                    <div class="image same-height-always">
                        <a href="https://Rachel-Shao.github.io/blog/2018/11/29/kubeedge%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97%E4%B8%80%E6%80%BB%E4%BD%93%E6%9E%B6%E6%9E%84%E5%88%86%E6%9E%90/">
                          
                            <img src="/img/placeholder.png" class="img-responsive" alt="kubeedge源码分析系列一：总体架构分析">
                          
                        </a>
                    </div>
                    <div class="name same-height-always">
                        <h5><a href="https://Rachel-Shao.github.io/blog/2018/11/29/kubeedge%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97%E4%B8%80%E6%80%BB%E4%BD%93%E6%9E%B6%E6%9E%84%E5%88%86%E6%9E%90/">kubeedge源码分析系列一：总体架构分析</a></h5>
                    </div>
                </div>
                
                <div class="item same-height-row clearfix">
                    <div class="image same-height-always">
                        <a href="https://Rachel-Shao.github.io/blog/2018/10/11/knative-serving%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/">
                          
                            <img src="/img/placeholder.png" class="img-responsive" alt="knative serving开发环境搭建">
                          
                        </a>
                    </div>
                    <div class="name same-height-always">
                        <h5><a href="https://Rachel-Shao.github.io/blog/2018/10/11/knative-serving%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/">knative serving开发环境搭建</a></h5>
                    </div>
                </div>
                
                <div class="item same-height-row clearfix">
                    <div class="image same-height-always">
                        <a href="https://Rachel-Shao.github.io/blog/2018/08/05/%E4%BB%8Econtaienrd-pull%E9%95%9C%E5%83%8F%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90oci-distribution-spec/">
                          
                            <img src="/img/blogs/921/dockerarchitecture.png" class="img-responsive" alt="从contaienrd pull镜像流程分析oci distribution spec">
                          
                        </a>
                    </div>
                    <div class="name same-height-always">
                        <h5><a href="https://Rachel-Shao.github.io/blog/2018/08/05/%E4%BB%8Econtaienrd-pull%E9%95%9C%E5%83%8F%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90oci-distribution-spec/">从contaienrd pull镜像流程分析oci distribution spec</a></h5>
                    </div>
                </div>
                
            </div>

            <hr class="hidden-md hidden-lg">
             

        </div>
        

        
        <div class="col-md-4 col-sm-6">

          <h4></h4>

            <p><strong>联系我们: 
                                    <p>团队负责人：丁轶群 yiqunding@zju.edu.cn</p>
                                    <p>网站维护人：冯志凌 502361391@qq.com</p>                
    </strong>

            

            <hr class="hidden-md hidden-lg hidden-sm">

        </div>
        
        

    </div>
    
</footer>







<div id="copyright">
    <div class="container">
        <div class="col-md-12">
            
            <p class="pull-left">Copyright ©️ 2020 SEL Laboratory , ZJ University all rights reserved.</p>
            
            <p class="pull-right">
               <a href="https://bootstrapious.com/p/universal-business-e-commerce-template">Bootstrapious</a>.
              

               <a href="https://github.com/devcows/hugo-universal-theme">DevCows</a>.
            </p>
        </div>
    </div>
</div>





    </div>
    

    
<script src="//code.jquery.com/jquery-3.1.1.min.js" integrity="sha256-hVVnYaiADRTO2PzUGmuLJr8BLUSjGIZsDYGmIJLv2b8=" crossorigin="anonymous"></script>
<script src="//maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script>

<script src="//cdnjs.cloudflare.com/ajax/libs/jquery-cookie/1.4.1/jquery.cookie.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/waypoints/4.0.1/jquery.waypoints.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/Counter-Up/1.0/jquery.counterup.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/jquery-parallax/1.1.3/jquery-parallax.js"></script>

<script src="/js/front.js"></script>


<script src="/js/owl.carousel.min.js"></script>



  </body>
</html>
