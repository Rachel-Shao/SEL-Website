<!DOCTYPE html>
<html lang="zh-CN">

  <head>
  <meta charset="utf-8">
  <meta name="robots" content="all,follow">
  <meta name="googlebot" content="index,follow,snippet,archive">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  
  <title>Docker源码分析（六）：Docker Daemon网络</title>
  <meta name="author" content="浙大SEL实验室" />
  
  
  
  
  <meta name="keywords" content="Docker">
  
  
  <meta name="description" content="">

  <meta name="generator" content="Hugo 0.74.2" />

  
  <link href='//fonts.googleapis.com/css?family=Roboto:400,100,100italic,300,300italic,500,700,800' rel='stylesheet' type='text/css'>

  
  <link rel="stylesheet" href="//use.fontawesome.com/releases/v5.11.2/css/all.css">
  <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">

  
  <link href="/css/animate.css" rel="stylesheet">

  
  
    <link href="/css/style.default.css" rel="stylesheet" id="theme-stylesheet">
  

  
  <link href="/css/custom.css" rel="stylesheet">

  
  
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
        <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->
  

  
  <link rel="shortcut icon" href="/img/favicon.ico" type="image/x-icon" />
  <link rel="apple-touch-icon" href="/img/apple-touch-icon.png" />

  
  <link href="/css/owl.carousel.css" rel="stylesheet">
  <link href="/css/owl.theme.css" rel="stylesheet">

  
  <link rel="alternate" href="https://Rachel-Shao.github.io/index.xml" type="application/rss+xml" title="浙大SEL实验室">

  
  
  
  
  
  
  <meta property="og:updated_time" content="2015-01-05T10:52:28Z">
  
    
    
    
    <meta property="article:tag" content="Docker">
    
    
    <meta property="article:published_time" content="2015-01-05T10:52:28Z">
    <meta property="article:modified_time" content="2015-01-05T10:52:28Z">
  

  
  <meta name="twitter:card" content="summary">
  
  <meta name="twitter:title" content="Docker源码分析（六）：Docker Daemon网络">
  
  <meta name="twitter:description" content="">
  

</head>


  <body>

    <div id="all">

        <header class="navbar-affixed-top" data-spy="affix" data-offset-top="62">
    <div class="navbar navbar-default yamm" role="navigation" id="navbar" style="background-color:white;">    
        <div class="container">
            <div class="navbar-header">
                <a class="navbar-brand home" href="/">
                    <img src="/img/sel.png" alt="Docker源码分析（六）：Docker Daemon网络" class="hidden-xs hidden-sm img-responsive">
                    
                    <span class="sr-only">Docker源码分析（六）：Docker Daemon网络 - </span>
                </a>
                <div class="navbar-buttons">
                    <button type="button" class="navbar-toggle btn-template-main" data-toggle="collapse" data-target="#navigation">
                      <span class="sr-only"></span>
                        <i class="fas fa-align-justify"></i>
                    </button>
                </div>
            </div>
            

            <div class="navbar-collapse collapse" id="navigation">
                <ul class="nav navbar-nav navbar-right">
                  
                  
                  <li class="dropdown">
                    
                    <a href="/">主页</a>
                    
                  </li>
                  
                  <li class="dropdown">
                    
                    <a href="/blog/">博客</a>
                    
                  </li>

                  <li class="dropdown">
                    
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">社区 <span class="caret"></span></a>
                  <ul class="dropdown-menu">
                    
                      <li><a href="https://www.servicemesher.com/">ServiceMesh社区</a></li>
                    
                      <li><a href="">kubeedge社区</a></li>

                      <li><a href="http://www.icsoft.zju.edu.cn/index.php">浙江大学智能计算与软件中心</a></li>
                    
                  </ul>

                  <li class="dropdown">
                    
                    <a href="/archives/">归档</a>
                    
                  </li>
                  
                  <li class="dropdown">
                    
                    <a href="/contact/">关于</a>
                    
                  </li>
                  
                </li>

                
                

                
                </ul>
            </div>
            

            <div class="collapse clearfix" id="search">    
                <form class="navbar-form" role="search">
                    <div class="input-group">
                        <input type="text" class="form-control" placeholder="Search">
                        <span class="input-group-btn">
                    <button type="submit" class="btn btn-template-main"><i class="fas fa-search"></i></button>
                </span>
                    </div>
                </form>
            </div>
            
        </div>
    </div>

    
</header>




        <div id="heading-breadcrumbs">
    <div class="container">
        <div class="row">
            <div class="col-md-12">
                <h1>Docker源码分析（六）：Docker Daemon网络</h1>
            </div>
        </div>
    </div>
</div>


        <div id="content">
            <div class="container">

                <div class="row">

                    

                    <div class="col-md-9" id="blog-post">

                        
                          <p class="text-muted text-uppercase mb-small text-right">
                            
                            
                            2015-01-05
                          </p>
                        

                        <div id="post-content">
                          <p>本文介绍docker daemon的网络模型。</p>
<!-- raw HTML omitted -->
<p><strong>摘要:</strong> Docker的容器特性和镜像特性已然为Docker实践者带来了诸多效益，然而Docker的网络特性却不能让用户满意。本文从Docker的网络模式入手，分析了Docker Daemon创建网络环境的详细流程，其中着重于分析Docker桥接模式的创建，为之后Docker Container创建网络环境做铺垫。</p>
<h1 id="前言"><strong>前言</strong></h1>
<p>Docker作为一个开源的轻量级虚拟化容器引擎技术，已然给云计算领域带来了新的发展模式。Docker借助容器技术彻底释放了轻量级虚拟化技术的威力，让容器的伸缩、应用的运行都变得前所未有的方便与高效。同时，Docker借助强大的镜像技术，让应用的分发、部署与管理变得史无前例的便捷。然而，Docker毕竟是一项较为新颖的技术，在Docker的世界中，用户并非一劳永逸，其中最为典型的便是Docker的网络问题。 毋庸置疑，对于Docker管理者和开发者而言，如何有效、高效的管理Docker容器之间的交互以及Docker容器的网络一直是一个巨大的挑战。目前，云计算领域中，绝大多数系统都采取分布式技术来设计并实现。然而，在原生态的Docker世界中，Docker的网络却是不具备跨宿主机能力的，这也或多或少滞后了Docker在云计算领域的高速发展。 工业界中，Docker的网络问题的解决势在必行，在此环境下，很多IT企业都开发了各自的新产品来帮助完善Docker的网络。这些企业中不乏像Google一样的互联网翘楚企业，同时也有不少初创企业率先出击，在最前沿不懈探索。这些新产品中有，Google推出的容器管理和编排开源项目Kubernetes，Zett.io公司开发的通过虚拟网络连接跨宿主机容器的工具Weave，CoreOS团队针对Kubernetes设计的网络覆盖工具Flannel，Docker官方的工程师Jérôme Petazzoni自己设计的SDN网络解决方案Pipework，以及SocketPlane项目等。 对于Docker管理者与开发者而言，Docker的跨宿主机通信能力固然重要，但Docker自身的网络架构也同样重要。只有深入了解Docker自身的网络设计与实现，才能在这基础上扩展Docker的跨宿主机能力。 Docker自身的网络主要包含两部分：Docker Daemon的网络配置，Docker Container的网络配置。本文主要分析Docker Daemon的网络。</p>
<h1 id="docker-daemon网络分析内容安排"><strong>Docker Daemon网络分析内容安排</strong></h1>
<p>本文从源码的角度，分析Docker Daemon在启动过程中，为Docker配置的网络环境，章节安排如下：</p>
<ol>
<li>Docker Daemon网络配置；</li>
<li>运行Docker Daemon网络初始化任务；</li>
<li>创建Docker网桥。</li>
</ol>
<p>本文为《Docker源码分析系列》第六篇——Docker Daemon网络篇，第七篇将安排Docker Container网络篇。</p>
<h1 id="docker-daemon网络配置"><strong>Docker Daemon网络配置</strong></h1>
<p>Docker环境中，Docker管理员完全有权限配置Docker Daemon运行过程中的网络模式。 关于Docker的网络模式，大家最熟知的应该就是“桥接”的模式。下图为桥接模式下，Docker的网络环境拓扑图（包括Docker Daemon网络环境和Docker Container网络环境）： <a href="http://www.sel.zju.edu.cn/wp-content/uploads/2015/01/17.jpg"><img src="http://www.sel.zju.edu.cn/wp-content/uploads/2015/01/17.jpg" alt="17"></a></p>
<p>图3.1 Docker网络桥接示意图</p>
<p>然而，“桥接”是Docker网络模式中最为常用的模式。除此之外，Docker还为用户提供了更多的可选项，下文将对此一一说来。</p>
<h2 id="docker-daemon网络配置接口"><strong>Docker Daemon网络配置接口</strong></h2>
<p>Docker Daemon每次启动的过程中，都会初始化自身的网络环境，这样的网络环境最终为Docker Container提供网络通信服务。 Docker管理员配置Docker的网络环境，可以在Docker Daemon启动时，通过Docker提供的接口来完成。换言之，可以使用docker二进制可执行文件，运行docker -d并添加相应的flag参数来完成。 其中涉及的flag参数有EnableIptables、EnableIpForward、BridgeIface、BridgeIP以及InterContainerCommunication。该五个参数的定义位于<a href="https://github.com/docker/docker/blob/v1.2.0/daemon/config.go#L51-L52">./docker/daemon/config.go</a>，具体代码如下：</p>
<p>flag.BoolVar(&amp;config.EnableIptables, []string{&quot;#iptables&rdquo;, &ldquo;-iptables&rdquo;}, true, &ldquo;Enable Docker&rsquo;s addition of iptables rules&rdquo;)
flag.BoolVar(&amp;config.EnableIpForward, []string{&quot;#ip-forward&rdquo;, &ldquo;-ip-forward&rdquo;}, true, &ldquo;Enable net.ipv4.ip_forward&rdquo;)
flag.StringVar(&amp;config.BridgeIP, []string{&quot;#bip&rdquo;, &ldquo;-bip&rdquo;}, &ldquo;&rdquo;, &ldquo;Use this CIDR notation address for the network bridge&rsquo;s IP, not compatible with -b&rdquo;)
flag.StringVar(&amp;config.BridgeIface, []string{&ldquo;b&rdquo;, &ldquo;-bridge&rdquo;}, &ldquo;&rdquo;, &ldquo;Attach containers to a pre-existing network bridge\nuse &lsquo;none&rsquo; to disable container networking&rdquo;)
flag.BoolVar(&amp;config.InterContainerCommunication, []string{&quot;#icc&rdquo;, &ldquo;-icc&rdquo;}, true, &ldquo;Enable inter-container communication&rdquo;)</p>
<p>以下介绍这5个flag的作用：</p>
<ul>
<li>EnableIptables：确保Docker对于宿主机上的iptables规则拥有添加权限；</li>
<li>EnableIpForward：确保net.ipv4.ip_forward可以使用，使得多网络接口设备模式下，数据报可以在网络设备之间转发；</li>
<li>BridgeIP：在Docker Daemon启动过程中，为网络环境中的网桥配置CIDR网络地址；</li>
<li>BridgeIface：为Docker网络环境指定具体的通信网桥，若BridgeIface的值为”none”，则说明不需要为Docker Container创建网桥服务，关闭Docker Container的网络能力；</li>
<li>InterContainerCommunication：确保Docker容器之间可以完成通信。</li>
</ul>
<p>除了Docker会使用到的5个flag参数之外，Docker在创建网络环境时，还使用一个DefaultIP变量，如下：</p>
<p>opts.IPVar(&amp;config.DefaultIp, []string{&quot;#ip&rdquo;, &ldquo;-ip&rdquo;}, &ldquo;0.0.0.0&rdquo;, &ldquo;Default IP address to use when binding container ports&rdquo;)</p>
<p>该变量的作用是：当绑定容器的端口时，将DefaultIp作为默认使用的IP地址。 具备了以上Docker Daemon的网络背景知识，以下着重举例分析使用BridgeIP和BridgeIface，在启动Docker Daemon时进行网络配置： <a href="http://www.sel.zju.edu.cn/wp-content/uploads/2015/01/18.png"><img src="http://www.sel.zju.edu.cn/wp-content/uploads/2015/01/18.png" alt="18"></a> 深入理解BridgeIface与BridgeIP，并熟练使用相应的flag参数，即做到了如何配置Docker Daemon的网络环境。需要特别注意的是，Docker Daemon的网络与Docker Container的网络存在很大的区别。Docker Daemon为Docker Container创建网络的大环境，Docker Container的网络需要Docker Daemon的网络提供支持，但不唯一。举一个形象的例子，Docker Daemon可以创建docker0网桥，为之后Docker Container的桥接模式提供支持，然而Docker Container仍然可以根据用户需求创建自身网络，其中Docker Container的网络可以是桥接模式的网络，同时也可以直接共享使用宿主机的网络接口，另外还有其他模式，会在《Docker源码分析》系列的第七篇——Docker Container网络篇中详细介绍。</p>
<h2 id="docker-daemon网络初始化"><strong>Docker Daemon网络初始化</strong></h2>
<p>正如上一节所言，Docker管理员可以通过与网络相关的flag参数BridgeIface与BridgeIP，来为Docker Daemon创建网路环境。最简单的，Docker管理员通过执行”docker -d”就已经完成了运行Docker Daemon，而Docker Daemon在启动的时候，根据以上两个flag参数的值，创建相应的网络环境。 Docker Daemon网络初始化流程图如下： <a href="http://www.sel.zju.edu.cn/wp-content/uploads/2015/01/19.jpg"><img src="http://www.sel.zju.edu.cn/wp-content/uploads/2015/01/19.jpg" alt="19"></a></p>
<p>图 3.2 Docker Daemon网络初始化流程图</p>
<p>Docker Daemon网络初始化的流程总体而言，主要是根据解析flag参数来决定到底建立哪种类型的网络环境。从流程图中可知，Docker Daemon创建网络环境时有两个分支，不难发现分支代表的分别是：为Docker创建一个网络驱动、以及对Docker的网络不做任何的操作。 以下参照Docker Daemon网络初始化流程图具体分析实现步骤。</p>
<h3 id="启动docker-daemon传递flag参数"><strong>启动Docker Daemon传递flag参数</strong></h3>
<p>用户启动Docker Daemon，并在命令行中选择性的传入所需要的flag参数。</p>
<h3 id="解析网络flag参数"><strong>解析网络flag参数</strong></h3>
<p>flag包对命令行中的flag参数进行解析，其中和Docker Daemon网络配置相关的flag参数有5个，分别是：EnableIptables、EnableIpForward、BridgeIP、BridgeIface以及InterContanierCommunication，各个flag参数的作用上文已有介绍。</p>
<h3 id="预处理flag参数"><strong>预处理flag参数</strong></h3>
<p>预处理与网络配置相关的flag参数信息，包括检测配置信息的兼容性、以及判断是否创建Docker网络环境。 首先检验是否会出现彼此不兼容的配置信息，源码位于<a href="https://github.com/docker/docker/blob/v1.2.0/daemon/daemon.go#L679-L685">./docker/daemon/daemon.go#L679-L685</a>。 这部分的兼容信息有两种。第一种是BridgeIP和BridgeIface配置信息的兼容性，具体表现为用户启动Docker Daemon时，若同时指定了BridgeIP和BridgIface的值，则出现兼容问题。原因为这两者属于互斥对，换言之，若用户指定了新建网桥的设备名，那么该网桥已经存在，无需指定网桥的IP地址BridgeIP；若用户指定了新建网桥的网络IP地址BridgeIP，那么该网桥肯定还没有新建成功，则Docker Daemon在新建网桥时使用默认网桥名“docker0”。具体如下：</p>
<p>// Check for mutually incompatible config options
if config.BridgeIface != &quot;&rdquo; &amp;&amp; config.BridgeIP != &quot;&rdquo; {
return nil, fmt.Errorf(&ldquo;You specified -b &amp; &ndash;bip, mutually exclusive options. Please specify only one.&quot;)
}</p>
<p>第二种是EnableIptables和InterContainerCommunication配置的兼容性，具体是指不能同时指定这两个flag参数为false。原因很简单，如果指定InterContainerCommunication为false，则说明Docker Daemon不允许创建的Docker容器之间互相进行通信。但是为了达到以上目的，Docker正是使用iptables过滤规则。因此，再次设定EnableIptables为false，关闭iptables的使用，即出现了自相矛盾的结果。代码如下：</p>
<p>if !config.EnableIptables &amp;&amp; !config.InterContainerCommunication {
return nil, fmt.Errorf(&ldquo;You specified &ndash;iptables=false with &ndash;icc=false. ICC uses iptables to function. Please set &ndash;icc or &ndash;iptables to true.&quot;)
}</p>
<p>检验完系统配置信息的兼容性问题，Docker Daemon接着会判断是否需要为Docker Daemon配置网络环境。判断的依据为BridgeIface的值是否与DisableNetworkBridge的值相等，DisableNetworkBridge在<a href="https://github.com/docker/docker/blob/v1.2.0/daemon/config.go#L13">./docker/daemon/config.go#L13</a>中被定义为const量，值为字符串”none”。因此，若BridgeIface为”none”，则DisableNetwork为true，最终Docker Daemon不会创建网络环境；若BridgeIface不为”none”，则DisableNetwork为false，最终Docker Daemon需要创建网络环境（桥接模式）。</p>
<h3 id="确定docker网络模式"><strong>确定Docker网络模式</strong></h3>
<p>Docker网络模式由配置信息DisableNetwork决定。由于在上一环节已经得出DisableNetwork的值，故这一环节可以确定Docker网络模式。该部分的源码实现位于<a href="https://github.com/docker/docker/blob/v1.2.0/daemon/daemon.go#L792-L805">./docker/daemon/daemon.go#L792-L805</a>，如下：</p>
<p>if !config.DisableNetwork {
job := eng.Job(&ldquo;init_networkdriver&rdquo;)</p>
<pre><code>job.SetenvBool(&quot;EnableIptables&quot;, config.EnableIptables)
job.SetenvBool(&quot;InterContainerCommunication&quot;, config.InterContainerCommunication)
job.SetenvBool(&quot;EnableIpForward&quot;, config.EnableIpForward)
job.Setenv(&quot;BridgeIface&quot;, config.BridgeIface)
job.Setenv(&quot;BridgeIP&quot;, config.BridgeIP)
job.Setenv(&quot;DefaultBindingIP&quot;, config.DefaultIp.String())

if err := job.Run(); err != nil {
    return nil, err
}
</code></pre>
<p>}</p>
<p>若DisableNetwork为false，则说明需要创建网络环境，具体的模式为创建Docker网桥模式。创建网络环境的步骤为：</p>
<ol>
<li>创建名为”init_networkdriver”的job；</li>
<li>为该job配置环境变量，设置的环境变量有EnableIptables、InterContainerCommunication、EnableIpForward、BridgeIface、BridgeIP以及DefaultBindingIP；</li>
<li>运行job。</li>
</ol>
<p>运行”init_network”即为创建Docker网桥，这部分内容将会在下一节详细分析。 若DisableNetwork为true。则说明不需要创建网络环境，网络模式属于none模式。 以上便是Docker Daemon网络初始化的所有流程。</p>
<h2 id="创建docker网桥"><strong>创建Docker网桥</strong></h2>
<p>Docker的网络往往是Docker开发者最常提起的话题。而Docker网络中最常使用的模式为bridge桥接模式。本小节将详细分析创建Docker网桥的创建流程。 创建Docker网桥的实现通过”init_network”这个job的运行来完成。”init_network”的实现为InitDriver函数，位于<a href="https://github.com/docker/docker/blob/v1.2.0/daemon/networkdriver/bridge/driver.go#L79">./docker/daemon/networkdriver/bridge/driver.go#L79</a>，运行流程如下： <a href="http://www.sel.zju.edu.cn/wp-content/uploads/2015/01/20.jpg"><img src="http://www.sel.zju.edu.cn/wp-content/uploads/2015/01/20.jpg" alt="20"></a></p>
<p>图3.3 Docker Daemon创建网桥流程图</p>
<h3 id="提取环境变量"><strong>提取环境变量</strong></h3>
<p>在InitDriver函数的实现过程中，Docker首先提取”init_networkdriver”这个job的环境变量。这样的环境变量共有6个，各自的作用在上文已经详细说明。具体的实现代码为：</p>
<p>var (
network        *net.IPNet
enableIPTables = job.GetenvBool(&ldquo;EnableIptables&rdquo;)
icc            = job.GetenvBool(&ldquo;InterContainerCommunication&rdquo;)
ipForward      = job.GetenvBool(&ldquo;EnableIpForward&rdquo;)
bridgeIP       = job.Getenv(&ldquo;BridgeIP&rdquo;)
)</p>
<p>if defaultIP := job.Getenv(&ldquo;DefaultBindingIP&rdquo;); defaultIP != &quot;&rdquo; {
defaultBindingIP = net.ParseIP(defaultIP)
}</p>
<p>bridgeIface = job.Getenv(&ldquo;BridgeIface&rdquo;)</p>
<h3 id="确定docker网桥设备名"><strong>确定Docker网桥设备名</strong></h3>
<p>提取job的环境变量之后，Docker随即确定最终使用网桥设备的名称。为此，Docker首先创建了一个名为usingDefaultBridge的bool变量，含义为是否使用默认的网桥设备，默认值为false。接着，若环境变量中bridgeIface的值为空，则说明用户启动Docker时，没有指定特定的网桥设备名，因此Docker首先将usingDefaultBridge置为true，然后使用默认的网桥设备名DefaultNetworkBridge，即docker0；若bridgeIface的值不为空，则判断条件不成立，继续往下执行。这部分的代码实现为：</p>
<p>usingDefaultBridge := false
if bridgeIface == &quot;&rdquo; {
usingDefaultBridge = true
bridgeIface = DefaultNetworkBridge
}</p>
<h3 id="查找bridgeiface网桥设备"><strong>查找bridgeIface网桥设备</strong></h3>
<p>确定Docker网桥设备名bridgeIface之后，Docker首先通过bridgeIface设备名在宿主机上查找该设备是否真实存在。若存在，则返回该网桥设备的IP地址，若不存在，则返回nil。实现代码位于<a href="https://github.com/docker/docker/blob/v1.2.0/daemon/networkdriver/bridge/driver.go#L99">./docker/daemon/networkdriver/bridge/driver.go#L99</a>，如下：</p>
<p>addr, err := networkdriver.GetIfaceAddr(bridgeIface)</p>
<p>GetIfaceAddr的实现位于./docker/daemon/networkdriver/utils.go，实现步骤为：首先通过Golang中net包的InterfaceByName方法获取名为bridgeIface的网桥设备，会得出以下结果：</p>
<ul>
<li>若名为bridgeIface的网桥设备不存在，直接返回error；</li>
<li>若名为bridgeIface的网桥设备存在，返回该网桥设备的IP地址。</li>
</ul>
<p>需要强调的是：GetIfaceAddr函数返回error，说明当前宿主机上不存在名为bridgeIface的网桥设备。而这样的结果会有两种不同的情况：第一，用户指定了bridgeIface，那么usingDefaultBridge为false，而该bridgeIface网桥设备在宿主机上不存在；第二，用户没有指定bridgeIface，那么usingDefaultBridge为true，bridgeIface名为docker0，而docker0网桥在宿主机上也不存在。 当然，若GetIfaceAddr函数返回的是一个IP地址，则说明当前宿主机上存在名为bridgeIface的网桥设备。这样的结果同样会有两种不同的情况：第一，用户指定了bridgeIface，那么usingDefaultBridge为false，而该bridgeIface网桥设备在宿主机上已经存在；第二，用户没有指定bridgeIface，那么usingDefaultBridge为true，bridgeIface名为docker0，而docker0网桥在宿主机上也已经存在。第二种情况一般是：用户在宿主机上第一次启动Docker Daemon时，创建了默认网桥设备docker0，而后docker0网桥设备一直存在于宿主机上，故之后在不指定网桥设备的情况下，重启Docker Daemon，会出现docker0已经存在的情况。 以下两小节将分别从bridgeIface已创建与bridgeIface未创建两种不同的情况分析。</p>
<h3 id="bridgeiface已创建的情况"><strong>bridgeIface已创建的情况</strong></h3>
<p>Docker Daemon所在宿主机上bridgeIface的网桥设备存在时，Docker Daemon仍然需要验证用户在配置信息中是否为网桥设备指定了IP地址。 用户启动Docker Daemon时，假如没有指定bridgeIP参数信息，则Docker Daemon使用名为bridgeIface的原有的IP地址。 当用户指定了bridgeIP参数信息时，则需要验证：指定的bridgeIP参数信息与bridgeIface网桥设备原有的IP地址信息是否匹配。若两者匹配，则验证通过，继续往下执行；若两者不匹配，则验证不通过，抛出错误，显示“bridgeIP与已有网桥配置信息不匹配”。该部分内容位于<a href="https://github.com/docker/docker/blob/v1.2.0/daemon/networkdriver/bridge/driver.go#L119-L129">./docker/daemon/networkdriver/bridge/driver.go#L119-L129</a>，代码如下：</p>
<p>network = addr.(*net.IPNet)
// validate that the bridge ip matches the ip specified by BridgeIP
if bridgeIP != &quot;&rdquo; {
bip, _, err := net.ParseCIDR(bridgeIP)
if err != nil {
return job.Error(err)
}
if !network.IP.Equal(bip) {
return job.Errorf(&ldquo;bridge ip (%s) does not match existing bridge configuration %s&rdquo;, network.IP, bip)
}
}</p>
<h3 id="bridgeiface未创建的情况"><strong>bridgeIface未创建的情况</strong></h3>
<p>Docker Daemon所在宿主机上bridgeIface的网桥设备未创建时，上文已经介绍将存在两种情况：</p>
<ul>
<li>用户指定的bridgeIface未创建；</li>
<li>用户未指定bridgeIface，而docker0暂未创建。</li>
</ul>
<p>当用户指定的bridgeIface不存在于宿主机时，即没有使用Docker的默认网桥设备名docker0，Docker打印日志信息“指定网桥设备未找到”，并返回网桥未找到的错误信息。代码实现如下：</p>
<p>if !usingDefaultBridge {
job.Logf(&ldquo;bridge not found: %s&rdquo;, bridgeIface)
return job.Error(err)
}</p>
<p>当使用的默认网桥设备名，而docker0网桥设备还未创建时，Docker Daemon则立即实现创建网桥的操作，并返回该docker0网桥设备的IP地址。代码如下：</p>
<p>// If the iface is not found, try to create it
job.Logf(&ldquo;creating new bridge for %s&rdquo;, bridgeIface)
if err := createBridge(bridgeIP); err != nil {
return job.Error(err)
}</p>
<p>job.Logf(&ldquo;getting iface addr&rdquo;)
addr, err = networkdriver.GetIfaceAddr(bridgeIface)
if err != nil {
return job.Error(err)
}
network = addr.(*net.IPNet)</p>
<p>创建Docker Daemon网桥设备docker0的实现，全部由createBridge(bridgeIP)来实现，createBridge的实现位于<a href="https://github.com/docker/docker/blob/v1.2.0/daemon/networkdriver/bridge/driver.go#L245">./docker/daemon/networkdriver/bridge/driver.go#L245</a>。 createBridge函数实现过程的主要步骤为：</p>
<ol>
<li>确定网桥设备docker0的IP地址；</li>
<li>通过createBridgeIface函数创建docker0网桥设备，并为网桥设备分配随机的MAC地址；</li>
<li>将第一步中已经确定的IP地址，添加给新创建的docker0网桥设备</li>
<li>启动docker0网桥设备。</li>
</ol>
<p>以下详细分析4个步骤的具体实现。 首先Docker Daemon确定docker0的IP地址，实现方式为判断用户是否指定bridgeIP。若用户未指定bridgeIP，则从Docker预先准备的IP网段列表addrs中查找合适的网段。具体的代码实现位于<a href="https://github.com/docker/docker/blob/v1.2.0/daemon/networkdriver/bridge/driver.go#L257-L278">./docker/daemon/networkdriver/bridge/driver.go#L257-L278</a>，如下：</p>
<p>if len(bridgeIP) != 0 {
_, _, err := net.ParseCIDR(bridgeIP)
if err != nil {
return err
}
ifaceAddr = bridgeIP
} else {
for _, addr := range addrs {
_, dockerNetwork, err := net.ParseCIDR(addr)
if err != nil {
return err
}
if err := networkdriver.CheckNameserverOverlaps(nameservers, dockerNetwork); err == nil {
if err := networkdriver.CheckRouteOverlaps(dockerNetwork); err == nil {
ifaceAddr = addr
break
} else {
log.Debugf(&quot;%s %s&rdquo;, addr, err)
}
}
}
}</p>
<p>其中为网桥设备准备的候选网段地址addrs为：</p>
<p>addrs = []string{
&ldquo;172.17.42.1/16&rdquo;, // Don&rsquo;t use 172.16.0.0/16, it conflicts with EC2 DNS 172.16.0.23
&ldquo;10.0.42.1/16&rdquo;,   // Don&rsquo;t even try using the entire /8, that&rsquo;s too intrusive
&ldquo;10.1.42.1/16&rdquo;,
&ldquo;10.42.42.1/16&rdquo;,
&ldquo;172.16.42.1/24&rdquo;,
&ldquo;172.16.43.1/24&rdquo;,
&ldquo;172.16.44.1/24&rdquo;,
&ldquo;10.0.42.1/24&rdquo;,
&ldquo;10.0.43.1/24&rdquo;,
&ldquo;192.168.42.1/24&rdquo;,
&ldquo;192.168.43.1/24&rdquo;,
&ldquo;192.168.44.1/24&rdquo;,
}</p>
<p>通过以上的流程的执行，可以确定找到一个可用的IP网段地址，为ifaceAddr；若没有找到，则返回错误日志，表明没有合适的IP地址赋予docker0网桥设备。 第二个步骤通过createBridgeIface函数创建docker0网桥设备。createBridgeIface函数的实现如下：</p>
<p>func createBridgeIface(name string) error {
kv, err := kernel.GetKernelVersion()
// only set the bridge&rsquo;s mac address if the kernel version is &gt; 3.3
// before that it was not supported
setBridgeMacAddr := err == nil &amp;&amp; (kv.Kernel &gt;= 3 &amp;&amp; kv.Major &gt;= 3)
log.Debugf(&ldquo;setting bridge mac address = %v&rdquo;, setBridgeMacAddr)
return netlink.CreateBridge(name, setBridgeMacAddr)
}</p>
<p>以上代码通过宿主机Linux内核信息，确定是否支持设定网桥设备的MAC地址。若Linux内核版本大于3.3，则支持配置MAC地址，否则则不支持。而Docker在不小于3.8的内核版本上运行才稳定，故可以认为内核支持配置MAC地址。最后通过netlink的CreateBridge函数实现创建docker0网桥。 Netlink是Linux中一种较为特殊的socket通信方式，提供了用户应用间和内核进行双向数据传输的途径。在这种模式下，用户态可以使用标准的socket API来使用netlink强大的功能，而内核态需要使用专门的内核API才能使用netlink。 Libcontainer的netlink包中CreateBridge实现了创建实际的网桥设备，具体使用系统调用的代码如下：</p>
<p>syscall.Syscall(syscall.SYS_IOCTL, uintptr(s), SIOC_BRADDBR, uintptr(unsafe.Pointer(nameBytePtr)))</p>
<p>创建完网桥设备之后，为docker0网桥设备配置MAC地址，实现函数为setBridgeMacAddress。 第三个步骤是为创建docker0网桥设备绑定IP地址。上一步骤仅完成了创建名为docker0的网桥设备，之后仍需要为docker0网桥设备绑定IP地址。具体代码实现为：</p>
<p>if netlink.NetworkLinkAddIp(iface, ipAddr, ipNet); err != nil {
return fmt.Errorf(&ldquo;Unable to add private network: %s&rdquo;, err)
}</p>
<p>NetworkLinkAddIP的实现同样位于libcontainer中的netlink包，主要的功能为：通过netlink机制为一个网络接口设备绑定一个IP地址。 第四个步骤是启动docker0网桥设备。具体实现代码为：</p>
<p>if err := netlink.NetworkLinkUp(iface); err != nil {
return fmt.Errorf(&ldquo;Unable to start network bridge: %s&rdquo;, err)
}</p>
<p>NetworkLinkUp的实现同样位于libcontainer中的netlink包，功能为启动docker网桥设备。 至此，docker0网桥历经确定IP、创建、绑定IP、启动四个环节，createBridge关于docker0网桥设备的工作全部完成。</p>
<h3 id="获取网桥设备的网络地址"><strong>获取网桥设备的网络地址</strong></h3>
<p>创建完网桥设备之后，网桥设备必然会存在一个网络地址。网桥网络地址的作用为：Docker Daemon在创建Docker Container时，使用该网络地址为Docker Container分配IP地址。 Docker使用代码network = addr.(*net.IPNet)获取网桥设备的网络地址。</p>
<h3 id="配置docker-daemon的iptables"><strong>配置Docker Daemon的iptables</strong></h3>
<p>创建完网桥之后，Docker Daemon为容器以及宿主机配置iptables，包括为container之间所需要的link操作提供支持，为host主机上所有的对外对内流量制定传输规则等。该部分详情可以参看<a href="http://www.sel.zju.edu.cn/?p=165">《Docker源码分析（四）：Docker Daemon之NewDaemon实现》</a>。代码位于<a href="https://github.com/docker/docker/blob/v1.2.0/daemon/networkdriver/bridge/driver.go#L133">./docker/daemon/networkdriver/bridge/driver/driver.go#L133</a>，如下：</p>
<p>// Configure iptables for link support
if enableIPTables {
if err := setupIPTables(addr, icc); err != nil {
return job.Error(err)
}
}</p>
<p>// We can always try removing the iptables
if err := iptables.RemoveExistingChain(&ldquo;DOCKER&rdquo;); err != nil {
return job.Error(err)
}</p>
<p>if enableIPTables {
chain, err := iptables.NewChain(&ldquo;DOCKER&rdquo;, bridgeIface)
if err != nil {
return job.Error(err)
}
portmapper.SetIptablesChain(chain)
}</p>
<h3 id="配置网络设备间数据报转发功能"><strong>配置网络设备间数据报转发功能</strong></h3>
<p>在Linux系统上，数据包转发功能是被默认禁止的。数据包转发，就是当host主机存在多个网络设备时，如果其中一个接收到数据包，并需要将其转发给另外的网络设备。通过修改/proc/sys/net/ipv4/ip_forward的值，将其置为1，则可以保证系统内数据包可以实现转发功能，代码如下：</p>
<p>if ipForward {
// Enable IPv4 forwarding
if err := ioutil.WriteFile(&quot;/proc/sys/net/ipv4/ip_forward&rdquo;, []byte{&lsquo;1&rsquo;, &lsquo;\n&rsquo;}, 0644); err != nil {
job.Logf(&ldquo;WARNING: unable to enable IPv4 forwarding: %s\n&rdquo;, err)
}
}</p>
<h3 id="注册网络handler"><strong>注册网络Handler</strong></h3>
<p>创建Docker Daemon网络环境的最后一个步骤是：注册4个与网络相关的Handler。这4个Handler分别是allocate_interface、release_interface、allocate_port和link，作用分别是为Docker Container分配网络设备，回收Docker Container网络设备、为Docker Container分配端口资源、以及为Docker Container间执行link操作。 至此，Docker Daemon的网络环境初始化工作全部完成。</p>
<h1 id="总结"><strong>总结</strong></h1>
<p>在工业界，Docker的网络问题备受关注。Docker的网络环境可以分为Docker Daemon网络和Docker Container网络。本文从Docker Daemon的网络入手，分析了大家熟知的Docker 桥接模式。 Docker的容器技术以及镜像技术，已经给Docker实践者带来了诸多效益。然而Docker网络的发展依然具有很大的潜力。下一篇Docker Container网络篇，将会带来更为灵活的Docker网络配置。 5 参考文献 <a href="http://www.cnblogs.com/iceocean/articles/1594195.html">LINUX netlink机制</a> <a href="http://docs.studygolang.com/pkg/net/">Package net</a> [simple-author-box]</p>

                        </div>
                        
                        
                        
                        
                        
                        <div id="SOHUCS"></div>
                        <script charset="utf-8" type="text/javascript" src="https://cy-cdn.kuaizhan.com/upload/changyan.js" ></script>
                        <script type="text/javascript">
                          window.changyan.api.config({
                          appid: 'cyuX8hDAj',
                          conf: 'prod_4e1f40d37469ca7d81688963c063f0f7'
                          });
                        </script>

                    </div>
                    

                    

                    

                    <div class="col-md-3">

                        

                        

<div class="panel panel-default sidebar-menu">

    <div class="panel-heading">
      <h3 class="panel-title">搜索栏</h3>
      
    </div>

    <div class="panel-body">
        
        <div class="search" id="search">
            <div class="input-group">
                <input type="text" name="q" class="form-control" placeholder="请输入文章标题或摘要..." id="search-key">
                <input type="hidden" name="sitesearch" value="https://Rachel-Shao.github.io/">
                <span class="input-group-btn">
                    <button type="submit" class="btn btn-template-main" onclick="search()"><i class="fas fa-search"></i></button>
                </span>
            </div>
            <h1 id="search-tip" style="color: red;text-align: center;display: none;font-size: medium;">搜索中，请稍后 ...</h1>
        </div>
        <script type="text/javascript">
            
            window.onload = function() {
                      document.onkeydown = function(ev) {
                        var event = ev || event
                        if (event.keyCode == 13) {
                          search()
                        }
                      }
                    }
            
            function search() {
                      key = document.getElementById("search-key").value;
                      if (key === "") {
                        
                        return;
                      }
                      document.getElementById("search-key").value = "";
                  
                      
                      document.getElementById("search-tip").innerText = "搜索中，请稍后 ...";
                      document.getElementById("search-tip").style.display = "block";
                  
                      
                      var el = document.getElementById('blog-listing-medium');
                      var childs = el.childNodes;
                      for (var i = childs.length - 1; i >= 0; i--) {
                        el.removeChild(childs[i]);
                      }
                  
                      
                      xmltext = new XMLHttpRequest;
                      xmltext.open("GET", "/index.xml", false);
                      xmltext.send();
                      resp = xmltext.responseXML;
                      items = resp.getElementsByTagName("item");
                      
                      var i = 0;
                      haveResult = false;
                      while (i < items.length) {
                        txt = items[i].getElementsByTagName("title")[0].innerHTML + items[i].getElementsByTagName("description")[0].innerHTML
                        if (txt.indexOf(key) > -1) {
                          haveResult = true;
                          title = items[i].getElementsByTagName("title")[0].innerHTML;
                          link = items[i].getElementsByTagName("link")[0].innerHTML;
                          time = items[i].getElementsByTagName("pubDate")[0].innerHTML;
                          mark = items[i].getElementsByTagName("description")[0].innerHTML;
                          addItem(title, link, time, mark)
                        }
                        i++;
                      }
                      if (!haveResult) {
                        document.getElementById("search-tip").innerText = "搜索完毕，未发现结果 ...";
                        document.getElementById("search-tip").style.display = "block";
                      }
                    }
                  
                    
                    function addItem(title, link, time, mark) {
                      document.getElementById("search-tip").style.display = "none";
                      tmpl = "<article class=\"post\" style=\"border-bottom: 1px solid #e6e6e6;\" >" +
                        "<header class=\"post-header\">" +
                        "<h1 class=\"post-title\"><a class=\"post-link\" href=\"" + link + "\" target=\"_blank\">" + title + "</a></h1>" +
                        "<div class=\"post-meta\">" +
                        " <span class=\"post-time\">" + time + "</span>" +
                        "</div>" +
                        " </header>" +
                        "<div class=\"post-content\">" +
                        "<div class=\"post-summary\">" + mark + "</div>" +
                        "<div class=\"read-more\">" +
                        "<a href=" + link + " class=\"read-more-link\" target=\"_blank\">阅读更多</a>" +
                        "</div>" +
                        " </div>" +
                        "</article>"
                      div = document.createElement("div")
                      div.innerHTML = tmpl;
                      document.getElementById('blog-listing-medium').appendChild(div)
                    }

        </script>
        
    </div>
</div>







<div class="panel panel-default sidebar-menu">

    <div class="panel-heading">
        <h3 class="panel-title">归档栏</h3>
        
    </div>

    <div class="panel-body">
        <ul class="nav nav-pills nav-stacked">
            
            
            <li>
                <a href="/categories/cloudfoundry">cloudfoundry (12)</a>
            </li>
            
            <li>
                <a href="/categories/contaienrd">contaienrd (1)</a>
            </li>
            
            <li>
                <a href="/categories/docker">docker (12)</a>
            </li>
            
            <li>
                <a href="/categories/kubernetes">kubernetes (1)</a>
            </li>
            
            <li>
                <a href="/categories/network">network (1)</a>
            </li>
            
        </ul>
    </div>

</div>








<div class="panel sidebar-menu">

    <div class="panel-heading">
        <h3 class="panel-title">标签栏</h3>
        
    </div>

    <div class="panel-body">
        <ul class="tag-cloud">
            
            
            <li>
                <a href="/tags/agent"><i class="fas fa-tags"></i> agent</a>
            </li>
            
            <li>
                <a href="/tags/apiserver"><i class="fas fa-tags"></i> apiserver</a>
            </li>
            
            <li>
                <a href="/tags/books"><i class="fas fa-tags"></i> books</a>
            </li>
            
            <li>
                <a href="/tags/bosh"><i class="fas fa-tags"></i> bosh</a>
            </li>
            
            <li>
                <a href="/tags/ccng"><i class="fas fa-tags"></i> ccng</a>
            </li>
            
            <li>
                <a href="/tags/cf-release"><i class="fas fa-tags"></i> cf-release</a>
            </li>
            
            <li>
                <a href="/tags/cgroups"><i class="fas fa-tags"></i> cgroups</a>
            </li>
            
            <li>
                <a href="/tags/cloud_controller_ng"><i class="fas fa-tags"></i> cloud_controller_ng</a>
            </li>
            
            <li>
                <a href="/tags/cloudfoundry"><i class="fas fa-tags"></i> cloudfoundry</a>
            </li>
            
            <li>
                <a href="/tags/cloudnative"><i class="fas fa-tags"></i> cloudnative</a>
            </li>
            
            <li>
                <a href="/tags/collector"><i class="fas fa-tags"></i> collector</a>
            </li>
            
            <li>
                <a href="/tags/containerd"><i class="fas fa-tags"></i> containerd</a>
            </li>
            
            <li>
                <a href="/tags/cri"><i class="fas fa-tags"></i> cri</a>
            </li>
            
            <li>
                <a href="/tags/dea"><i class="fas fa-tags"></i> dea</a>
            </li>
            
            <li>
                <a href="/tags/docker"><i class="fas fa-tags"></i> docker</a>
            </li>
            
            <li>
                <a href="/tags/docker-network"><i class="fas fa-tags"></i> docker-network</a>
            </li>
            
            <li>
                <a href="/tags/edgecomputing"><i class="fas fa-tags"></i> edgecomputing</a>
            </li>
            
            <li>
                <a href="/tags/etcd"><i class="fas fa-tags"></i> etcd</a>
            </li>
            
            <li>
                <a href="/tags/gorouter"><i class="fas fa-tags"></i> gorouter</a>
            </li>
            
            <li>
                <a href="/tags/haproxy"><i class="fas fa-tags"></i> haproxy</a>
            </li>
            
            <li>
                <a href="/tags/healthmanager"><i class="fas fa-tags"></i> healthmanager</a>
            </li>
            
            <li>
                <a href="/tags/istio"><i class="fas fa-tags"></i> istio</a>
            </li>
            
            <li>
                <a href="/tags/kubeedge"><i class="fas fa-tags"></i> kubeedge</a>
            </li>
            
            <li>
                <a href="/tags/kubelet"><i class="fas fa-tags"></i> kubelet</a>
            </li>
            
            <li>
                <a href="/tags/kubernetes"><i class="fas fa-tags"></i> kubernetes</a>
            </li>
            
            <li>
                <a href="/tags/libcontainer"><i class="fas fa-tags"></i> libcontainer</a>
            </li>
            
            <li>
                <a href="/tags/micro-service"><i class="fas fa-tags"></i> micro-service</a>
            </li>
            
            <li>
                <a href="/tags/namespace"><i class="fas fa-tags"></i> namespace</a>
            </li>
            
            <li>
                <a href="/tags/nats"><i class="fas fa-tags"></i> nats</a>
            </li>
            
            <li>
                <a href="/tags/news"><i class="fas fa-tags"></i> news</a>
            </li>
            
            <li>
                <a href="/tags/pipework"><i class="fas fa-tags"></i> pipework</a>
            </li>
            
            <li>
                <a href="/tags/pouch"><i class="fas fa-tags"></i> pouch</a>
            </li>
            
            <li>
                <a href="/tags/runc"><i class="fas fa-tags"></i> runc</a>
            </li>
            
            <li>
                <a href="/tags/runtime"><i class="fas fa-tags"></i> runtime</a>
            </li>
            
            <li>
                <a href="/tags/security"><i class="fas fa-tags"></i> security</a>
            </li>
            
            <li>
                <a href="/tags/serverless"><i class="fas fa-tags"></i> serverless</a>
            </li>
            
            <li>
                <a href="/tags/service-mesh"><i class="fas fa-tags"></i> service-mesh</a>
            </li>
            
            <li>
                <a href="/tags/syslog_aggregator"><i class="fas fa-tags"></i> syslog_aggregator</a>
            </li>
            
        </ul>
    </div>

</div>






                        

                    </div>
                    

                    

                </div>
                

            </div>
            
        </div>
        

        <footer id="footer">
    <div class="container">

        
        <div class="col-md-4 col-sm-6">
            <h4></h4>

            <p><strong>关于我们：<strong> <p>浙大SEL实验室</p><p>地址：杭州市浙大路38号曹光彪西楼405室</p><p><strong></strong>
            <a href="/contact" class="btn btn-small btn-template-main" >跳转到关于</a>

            <hr class="hidden-md hidden-lg hidden-sm">

        </div>
        
        

        <div class="col-md-4 col-sm-6">

             
            <h4>最新博客</h4>
            

            <div class="blog-entries">
                
                <div class="item same-height-row clearfix">
                    <div class="image same-height-always">
                        <a href="https://Rachel-Shao.github.io/blog/2018/11/29/kubeedge%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97%E4%B8%80%E6%80%BB%E4%BD%93%E6%9E%B6%E6%9E%84%E5%88%86%E6%9E%90/">
                          
                            <img src="/img/placeholder.png" class="img-responsive" alt="kubeedge源码分析系列一：总体架构分析">
                          
                        </a>
                    </div>
                    <div class="name same-height-always">
                        <h5><a href="https://Rachel-Shao.github.io/blog/2018/11/29/kubeedge%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97%E4%B8%80%E6%80%BB%E4%BD%93%E6%9E%B6%E6%9E%84%E5%88%86%E6%9E%90/">kubeedge源码分析系列一：总体架构分析</a></h5>
                    </div>
                </div>
                
                <div class="item same-height-row clearfix">
                    <div class="image same-height-always">
                        <a href="https://Rachel-Shao.github.io/blog/2018/10/11/knative-serving%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/">
                          
                            <img src="/img/placeholder.png" class="img-responsive" alt="knative serving开发环境搭建">
                          
                        </a>
                    </div>
                    <div class="name same-height-always">
                        <h5><a href="https://Rachel-Shao.github.io/blog/2018/10/11/knative-serving%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/">knative serving开发环境搭建</a></h5>
                    </div>
                </div>
                
                <div class="item same-height-row clearfix">
                    <div class="image same-height-always">
                        <a href="https://Rachel-Shao.github.io/blog/2018/08/05/%E4%BB%8Econtaienrd-pull%E9%95%9C%E5%83%8F%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90oci-distribution-spec/">
                          
                            <img src="/img/blogs/921/dockerarchitecture.png" class="img-responsive" alt="从contaienrd pull镜像流程分析oci distribution spec">
                          
                        </a>
                    </div>
                    <div class="name same-height-always">
                        <h5><a href="https://Rachel-Shao.github.io/blog/2018/08/05/%E4%BB%8Econtaienrd-pull%E9%95%9C%E5%83%8F%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90oci-distribution-spec/">从contaienrd pull镜像流程分析oci distribution spec</a></h5>
                    </div>
                </div>
                
            </div>

            <hr class="hidden-md hidden-lg">
             

        </div>
        

        
        <div class="col-md-4 col-sm-6">

          <h4></h4>

            <p><strong>联系我们: 
                                    <p>团队负责人：丁轶群 yiqunding@zju.edu.cn</p>
                                    <p>网站维护人：冯志凌 502361391@qq.com</p>                
    </strong>

            

            <hr class="hidden-md hidden-lg hidden-sm">

        </div>
        
        

    </div>
    
</footer>







<div id="copyright">
    <div class="container">
        <div class="col-md-12">
            
            <p class="pull-left">Copyright ©️ 2020 SEL Laboratory , ZJ University all rights reserved.</p>
            
            <p class="pull-right">
               <a href="https://bootstrapious.com/p/universal-business-e-commerce-template">Bootstrapious</a>.
              

               <a href="https://github.com/devcows/hugo-universal-theme">DevCows</a>.
            </p>
        </div>
    </div>
</div>





    </div>
    

    
<script src="//code.jquery.com/jquery-3.1.1.min.js" integrity="sha256-hVVnYaiADRTO2PzUGmuLJr8BLUSjGIZsDYGmIJLv2b8=" crossorigin="anonymous"></script>
<script src="//maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script>

<script src="//cdnjs.cloudflare.com/ajax/libs/jquery-cookie/1.4.1/jquery.cookie.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/waypoints/4.0.1/jquery.waypoints.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/Counter-Up/1.0/jquery.counterup.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/jquery-parallax/1.1.3/jquery-parallax.js"></script>

<script src="/js/front.js"></script>


<script src="/js/owl.carousel.min.js"></script>



  </body>
</html>
