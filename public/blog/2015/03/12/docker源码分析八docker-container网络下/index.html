<!DOCTYPE html>
<html lang="zh-CN">

  <head>
  <meta charset="utf-8">
  <meta name="robots" content="all,follow">
  <meta name="googlebot" content="index,follow,snippet,archive">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  
  <title>Docker源码分析（八）：Docker Container网络（下）</title>
  <meta name="author" content="孙宏亮" />
  
  
  
  
  <meta name="keywords" content="Docker">
  
  
  <meta name="description" content="">

  <meta name="generator" content="Hugo 0.74.2" />

  
  <link href='//fonts.googleapis.com/css?family=Roboto:400,100,100italic,300,300italic,500,700,800' rel='stylesheet' type='text/css'>

  
  <link rel="stylesheet" href="//use.fontawesome.com/releases/v5.11.2/css/all.css">
  <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">

  
  <link href="/css/animate.css" rel="stylesheet">

  
  
    <link href="/css/style.default.css" rel="stylesheet" id="theme-stylesheet">
  

  
  <link href="/css/custom.css" rel="stylesheet">

  
  
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
        <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->
  

  
  <link rel="shortcut icon" href="/img/favicon.ico" type="image/x-icon" />
  <link rel="apple-touch-icon" href="/img/apple-touch-icon.png" />

  
  <link href="/css/owl.carousel.css" rel="stylesheet">
  <link href="/css/owl.theme.css" rel="stylesheet">

  
  <link rel="alternate" href="https://Rachel-Shao.github.io/index.xml" type="application/rss+xml" title="浙大SEL实验室">

  
  
  
  
  
  
  <meta property="og:updated_time" content="2015-03-12T20:03:21Z">
  
    
    
    <meta property="article:section" content="Docker">
    <meta property="article:tag" content="Docker">
    
    
    <meta property="article:published_time" content="2015-03-12T20:03:21Z">
    <meta property="article:modified_time" content="2015-03-12T20:03:21Z">
  

  
  <meta name="twitter:card" content="summary">
  
  <meta name="twitter:title" content="Docker源码分析（八）：Docker Container网络（下）">
  
  <meta name="twitter:description" content="">
  

</head>


  <body>

    <div id="all">

        <header class="navbar-affixed-top" data-spy="affix" data-offset-top="62">
    <div class="navbar navbar-default yamm" role="navigation" id="navbar" style="background-color:white;">    
        <div class="container">
            <div class="navbar-header">
                <a class="navbar-brand home" href="/">
                    <img src="/img/sel.png" alt="Docker源码分析（八）：Docker Container网络（下）" class="hidden-xs hidden-sm img-responsive">
                    
                    <span class="sr-only">Docker源码分析（八）：Docker Container网络（下） - </span>
                </a>
                <div class="navbar-buttons">
                    <button type="button" class="navbar-toggle btn-template-main" data-toggle="collapse" data-target="#navigation">
                      <span class="sr-only"></span>
                        <i class="fas fa-align-justify"></i>
                    </button>
                </div>
            </div>
            

            <div class="navbar-collapse collapse" id="navigation">
                <ul class="nav navbar-nav navbar-right">
                  
                  
                  <li class="dropdown">
                    
                    <a href="/">主页</a>
                    
                  </li>
                  
                  <li class="dropdown">
                    
                    <a href="/blog/">博客</a>
                    
                  </li>

                  <li class="dropdown">
                    
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">社区 <span class="caret"></span></a>
                  <ul class="dropdown-menu">
                    
                      <li><a href="https://www.servicemesher.com/">ServiceMesh社区</a></li>
                    
                      <li><a href="">kubeedge社区</a></li>

                      <li><a href="http://www.icsoft.zju.edu.cn/index.php">浙江大学智能计算与软件中心</a></li>
                    
                  </ul>

                  <li class="dropdown">
                    
                    <a href="/archives/">归档</a>
                    
                  </li>
                  
                  <li class="dropdown">
                    
                    <a href="/contact/">关于</a>
                    
                  </li>
                  
                </li>

                
                

                
                </ul>
            </div>
            

            <div class="collapse clearfix" id="search">    
                <form class="navbar-form" role="search">
                    <div class="input-group">
                        <input type="text" class="form-control" placeholder="Search">
                        <span class="input-group-btn">
                    <button type="submit" class="btn btn-template-main"><i class="fas fa-search"></i></button>
                </span>
                    </div>
                </form>
            </div>
            
        </div>
    </div>

    
</header>




        <div id="heading-breadcrumbs">
    <div class="container">
        <div class="row">
            <div class="col-md-12">
                <h1>Docker源码分析（八）：Docker Container网络（下）</h1>
            </div>
        </div>
    </div>
</div>


        <div id="content">
            <div class="container">

                <div class="row">

                    

                    <div class="col-md-9" id="blog-post">

                        
                          <p class="text-muted text-uppercase mb-small text-right">
                             <a href="#">孙宏亮</a>
                             | 
                            2015-03-12
                          </p>
                        

                        <div id="post-content">
                          <h2 id="1docker-client配置容器网络模式"><strong>1.Docker Client配置容器网络模式</strong></h2>
<p>Docker目前支持4种网络模式，分别是bridge、host、container、none，Docker开发者可以根据自己的需求来确定最适合自己应用场景的网络模式。 从Docker Container网络创建流程图中可以看到，创建流程第一个涉及的Docker模块即为Docker Client。当然，这也十分好理解，毕竟Docker Container网络环境的创建需要由用户发起，用户根据自身对容器的需求，选择网络模式，并将其通过Docker Client传递给Docker Daemon。</p>
<p>本节，即从Docker Client源码的角度，分析如何配置Docker Container的网络模式，以及Docker Client内部如何处理这些网络模式参数。 需要注意的是：配置Docker Container网络环境与创建Docker Container网络环境有一些区别。区别是：配置网络环境指用户通过向Docker Client传递网络参数，实现Docker Container网络环境参数的配置，这部分配置由Docker Client传递至Docker Daemon，并由Docker Daemon保存；创建网络环境指，用户通过Docker Client向Docker Daemon发送容器启动命令之后，Docker Daemon根据之前保存的网络参数，实现Docker Container的启动，并在启动过程中完成Docker Container网络环境的创建。 以上的基本知识，理解下文的Docker Container网络环境创建流程。</p>
<h3 id="11-docker-client使用"><strong>1.1 Docker Client使用</strong></h3>
<p>Docker架构中，用户可以通过Docker Client来配置Docker Container的网络模式。配置过程主要通过docker run命令来完成，实现配置的方式是在docker run命令中添加网络参数。使用方式如下（其中NETWORKMODE为四种网络模式之一，ubuntu为镜像名称，/bin/bash为执行指令）:</p>
<p>docker run -d &ndash;net NETWORKMODE ubuntu /bin/bash</p>
<p>运行以上命令时，首先创建一个Docker Client，然后Docker Client会解析整条命令的请求内容，接着解析出为run请求，意为运行一个Docker Container，最终通过Docker Client端的API接口，调用CmdRun函数完成run请求执行。（详情可以查阅<a href="http://www.sel.zju.edu.cn/?p=147">《Docker源码分析》系列的第二篇——Docker Client篇</a>）。 Docker Client解析出run命令之后，立即调用相应的处理函数CmdRun进行处理关于run请求的具体内容。CmdRun的作用主要可以归纳为三点：</p>
<ul>
<li>解析Docker Client传入的参数，解析出config、hostconfig和cmd对象等；</li>
<li>发送请求至Docker Daemon，创建一个container对象，完成Docker Container启动前的准备工作；</li>
<li>发送请求至Docker Daemon，启动相应的Docker Container（包含创建Docker Container网络环境创建）。</li>
</ul>
<h3 id="12-runconfig包解析"><strong>1.2 runconfig包解析</strong></h3>
<p>CmdRun函数的实现位于<a href="https://github.com/docker/docker/blob/v1.2.0/api/client/commands.go#L1990">./docker/api/client/commands.go</a>。CmdRun执行的第一个步骤为：通过runconfig包中ParseSubcommand函数解析Docker Client传入的参数，并从中解析出相应的config，hostConfig以及cmd对象，实现代码如下:</p>
<pre><code>    config, hostConfig, cmd, err := runconfig.ParseSubcommand
    (cli.Subcmd(&quot;run&quot;, &quot;[OPTIONS] IMAGE [COMMAND] [ARG...]&quot;, 
    &quot;Run a command in a new container&quot;), args, nil) 
</code></pre>
<p>其中，config的类型为Config结构体，hostConfig的类型为HostConfig结构体，两种类型的定义均位于runconfig包。Config与HostConfig类型同用以描述Docker Container的配置信息，然而两者之间又有着本质的区别，最大的区别在于两者各自的作用范畴：</p>
<ul>
<li>Config结构体：描述Docker Container独立的配置信息。独立的含义是：Config这部分信息描述的是容器本身，而不会与容器所在host宿主机相关；</li>
<li>HostConfig结构体：描述Docker Container与宿主机相关的配置信息。</li>
</ul>
<h4 id="121-config结构体"><strong>1.2.1 Config结构体</strong></h4>
<p>Config结构体描述Docker Container本身的属性信息，这些信息与容器所在的host宿主机无关。结构体的定义如下：</p>
<pre><code>    type Config struct {
        Hostname        string
        Domainname      string
        User            string
        Memory          int64  // Memory limit (in bytes)
        MemorySwap      int64  // Total memory usage (memory + swap); set \`-1' to disable swap
        CpuShares       int64  // CPU shares (relative weight vs. other containers)
        Cpuset          string // Cpuset 0-2, 0,1
        AttachStdin     bool
        AttachStdout    bool
        AttachStderr    bool
        PortSpecs       []string // Deprecated - Can be in the format of 8080/tcp
        ExposedPorts    map[nat.Port]struct{}
        Tty             bool // Attach standard streams to a tty, including stdin if it is not closed.
        OpenStdin       bool // Open stdin
        StdinOnce       bool // If true, close stdin after the 1 attached client disconnects.
        Env             []string
        Cmd             []string
        Image           string // Name of the image as it was passed by 
    the operator (eg. could be symbolic)
        Volumes         map\[string\]struct{}
        WorkingDir      string
        Entrypoint      []string
        NetworkDisabled bool
        OnBuild         []string
    }
</code></pre>
<p>Config结构体中各属性的详细解释如下表：</p>
<p><a href="https://res.cloudinary.com/feesuper/image/upload/v1604132962/sel%E5%AE%9E%E9%AA%8C%E5%AE%A4%E5%8D%9A%E5%AE%A2/blogs/537/CONTAINER1_dibqeg.png"><img src="https://res.cloudinary.com/feesuper/image/upload/v1604132962/sel%E5%AE%9E%E9%AA%8C%E5%AE%A4%E5%8D%9A%E5%AE%A2/blogs/537/CONTAINER1_dibqeg.png" alt="23"></a></p>
<h4 id="122-hostconfig结构体"><strong>1.2.2 HostConfig结构体</strong></h4>
<p>HostConfig结构体描述Docker Container与宿主机相关的属性信息，结构体的定义如下：</p>
<pre><code>    type HostConfig struct {
        Binds           []string
        ContainerIDFile string
        LxcConf         []utils.KeyValuePair
        Privileged      bool
        PortBindings    nat.PortMap
        Links           []string
        PublishAllPorts bool
        Dns             []string
        DnsSearch       []string
        VolumesFrom     []string
        Devices         []DeviceMapping
        NetworkMode     NetworkMode
        CapAdd          []string
        CapDrop         []string
        RestartPolicy   RestartPolicy
    }
</code></pre>
<p>Config结构体中各属性的详细解释如下表：</p>
<p><a href="https://res.cloudinary.com/feesuper/image/upload/v1604132962/sel%E5%AE%9E%E9%AA%8C%E5%AE%A4%E5%8D%9A%E5%AE%A2/blogs/537/CONTAINER2_sjni6e.png"><img src="https://res.cloudinary.com/feesuper/image/upload/v1604132962/sel%E5%AE%9E%E9%AA%8C%E5%AE%A4%E5%8D%9A%E5%AE%A2/blogs/537/CONTAINER2_sjni6e.png" alt="24"></a></p>
<h4 id="123-runconfig解析网络模式"><strong>1.2.3 runconfig解析网络模式</strong></h4>
<p>讲述完Config与HostConfig结构体之后，回到runconfig包中分析如何解析与Docker Container网络模式相关的配置信息，并将这部分信息传递给config实例与hostConfig实例。 runconfig包中的ParseSubcommand函数调用parseRun函数完成命令请求的分析，实现代码位于<a href="https://github.com/docker/docker/blob/v1.2.0/runconfig/parse.go#L37-L39">./docker/runconfig/parse.go#L37-L39</a>，如下：</p>
<pre><code>    func ParseSubcommand(cmd *flag.FlagSet, args []string,
    sysInfo *sysinfo.SysInfo) (*Config, *HostConfig, *flag.FlagSet, error) {
            return parseRun(cmd, args, sysInfo)
    }
</code></pre>
<p>进入parseRun函数即可发现：该函数完成了四方面的工作：</p>
<ul>
<li>定义与容器配置信息相关的<a href="https://github.com/docker/docker/blob/v1.2.0/runconfig/parse.go#L42-L97">flag参数</a>；</li>
<li>解析docker run命令后紧跟的请求内容，将请求内容全部保存至flag参数中，余下的内容一个为镜像image名，另一个为需要在容器内执行的cmd命令；</li>
<li>通过flag参数验证参数的有效性，并处理得到Config结构体与HostConfig结构体需要的属性值；</li>
<li>创建并初始化Config类型实例config、HostConfig类型实例hostConfig，最总返回config、hostConfig与cmd。</li>
</ul>
<p>本文主要分析Docker Container的网络模式，而parseRun函数中有关容器网络模式的flag参数有flNetwork与flNetMode，两者的定义分别位于<a href="https://github.com/docker/docker/blob/v1.2.0/runconfig/parse.go#L62">./docker/runconfig/parse.go#L62</a>与<a href="https://github.com/docker/docker/blob/v1.2.0/runconfig/parse.go#L75">./docker/runconfig/parse.go#L75</a>，如下：</p>
<pre><code>    flNetwork = cmd.Bool([]string{&quot;#n&quot;, &quot;#-networking&quot;}, true, &quot;Enable networking for this container&quot;)

    flNetMode = cmd.String([]string{&quot;-net&quot;}, &quot;bridge&quot;, &quot;Set the Network mode for the container\n'bridge': creates a new network stack for the container on the docker bridge\n'none': no networking for this container\n'container:&lt;name|id&gt;': reuses another container network stack\n'host': use the host network stack inside the container. Note: the host mode gives the container full access to local system services such as D-bus and is therefore considered insecure.&quot;)
</code></pre>
<p>可见flag参数flNetwork表示是否开启容器的网络模式，若为true则开启，说明需要给容器创建网络环境；否则不开启，说明不给容器赋予网络功能。该flag参数的默认值为true，另外使用该flag的方式为：在docker run之后设定&ndash;networking或者-n，如：</p>
<pre><code>    docker run --networking true ubuntu /bin/bash
</code></pre>
<p>另一个flag参数flNetMode则表示为容器设定的网络模式，共有四种选项，分别是：bridge、none、container:&lt;name|id&gt;和host。四种模式的作用上文已经详细解释，此处不再赘述。使用该flag的方式为：在docker run之后设定&ndash;net，如：</p>
<pre><code>    Docker run --net host ubuntu /bin/bash
</code></pre>
<p>用户使用docker run启动容器时设定了以上两个flag参数（&ndash;networking和&ndash;net），则runconfig包会解析出这两个flag的值。最终，通过flag参数flNetwork，得到Config类型实例config的属性NetworkDisabled；通过flag参数flNetMode，得到HostConfig类型实例hostConfig的属性NetworkMode。 函数parseRun返回config、hostConfig与cmd，代表着runconfig包解析配置参数工作的完成，CmdRun得到返回内容之后，继续向下执行。</p>
<h3 id="13-cmdrun执行"><strong>1.3 CmdRun执行</strong></h3>
<p>在runconfig包中已经将有关容器网络模式的配置置于config对象与hostConfig对象，故在CmdRun函数的执行中，更多的是基于config对象与hostConfig参数处理配置信息，而没有其他的容器网络处理部分。 CmdRun后续主要工作是：利用Docker Daemon暴露的RESTful API接口，将docker run的请求发送至Docker Daemon。以下是CmdRun执行过程中Docker Client与Docker Daemon的简易交互图。</p>
<p><a href="https://res.cloudinary.com/feesuper/image/upload/v1604132962/sel%E5%AE%9E%E9%AA%8C%E5%AE%A4%E5%8D%9A%E5%AE%A2/blogs/537/CONTAINER3_op9nx8.jpg"><img src="https://res.cloudinary.com/feesuper/image/upload/v1604132962/sel%E5%AE%9E%E9%AA%8C%E5%AE%A4%E5%8D%9A%E5%AE%A2/blogs/537/CONTAINER3_op9nx8.jpg" alt="25"></a></p>
<p>图1.1 CmdRun中Docker Client与Docker Daemon交互图</p>
<p>具体分析CmdRun的执行流程可以发现：在解析config、hostConfig与cmd之后，Docker Client首先发起请求create container。若Docker Daemon节点上已经存在该容器所需的镜像，则立即执行create container操作并返回请求响应；Docker Client收到响应后，再发起请求start container。若容器镜像还不存在，Docker Daemon返回一个404的错误，表示镜像不存在；Docker Client收到错误响应之后，再发起一个请求pull image，使Docker Daemon首先下载镜像，下载完毕之后Docker Client再次发起请求create container，Docker Daemon创建完毕之后，Docker Client最终发起请求start container。 总结而言，Docker Client负责创建容器请求的发起。关于Docker Container网络环境的配置参数存储于config与hostConfig对象之中，在请求create container和start container发起时，随请求一起发送至Docker Daemon。</p>
<h2 id="2docker-daemon创建容器网络流程"><strong>2.Docker Daemon创建容器网络流程</strong></h2>
<p>Docker Daemon接收到Docker Client的请求大致可以分为两次，第一次为create container，第二次为start container。这两次请求的执行过程中，都与Docker Container的网络相关。以下按照这两个请求的执行，具体分析Docker Container网络模式的创建。Docker Daemon如何通过Docker Server解析RESTful请求，并完成分发调度处理，在《Docker源码分析》系列的第五篇——Docker Server篇中已经详细分析过，本文不再赘述。</p>
<h3 id="21创建容器并配置网络参数"><strong>2.1创建容器并配置网络参数</strong></h3>
<p>Docker Daemon首先接收并处理create container请求。需要注意的是：create container并非创建了一个运行的容器，而是完成了以下三个主要的工作：</p>
<ul>
<li>通过runconfig包解析出create container请求中与Docker Container息息相关的config对象；</li>
<li>在Docker Daemon内部创建了与Docker Container对应的container对象；</li>
<li>完成Docker Container启动前的准备化工作，如准备所需镜像、创建rootfs等。</li>
</ul>
<p>创建容器过程中，Docker Daemon首先通过runconfig包中ContainerConfigFromJob函数，解析出请求中的config对象，解析过程代码如下：</p>
<p>config := runconfig.ContainerConfigFromJob(job)</p>
<p>至此，Docker Client处理得到的config对象，已经传递至Docker Daemon的config对象，config对象中已经含有属性NetworkDisabled具体值。 处理得到config对象之后，Docker Daemon紧接着创建container对象，并为Docker Container作相应的准备工作。具体的实现代码位于<a href="https://github.com/docker/docker/blob/v1.2.0/daemon/create.go#L73-L78">./docker/daemon/create.go#L73-L78</a>，如下：</p>
<pre><code>    if container, err = daemon.newContainer(name, config, img); err != nil {
        return nil, nil, err
    }
    if err := daemon.createRootfs(container, img); err != nil {
        return nil, nil, err
    }
</code></pre>
<p>与Docker Container网络模式配置相关的内容主要位于创建container对象中。newContainer函数的定义位于<a href="https://github.com/docker/docker/blob/v1.2.0/daemon/daemon.go#L516-L550">./docker/daemon/daemon.go#L516-L550</a>，具体的container对象如下：</p>
<pre><code>    container := &amp;Container{
        ID:              id,
        Created:         time.Now().UTC(),
        Path:            entrypoint,
        Args:            args, //FIXME: de-duplicate from config
        Config:          config,
        hostConfig:      &amp;runconfig.HostConfig{},
        Image:           img.ID, // Always use the resolved image id
        NetworkSettings: &amp;NetworkSettings{},
        Name:            name,
        Driver:          daemon.driver.String(),
        ExecDriver:      daemon.execDriver.Name(),
        State:           NewState(),    
    }
</code></pre>
<p>在container对象中，config对象直接赋值给container对象的Config属性，另外hostConfig属性与NetworkSeeetings属性均为空。其中hostConfig对象将在start container请求执行过程中被赋值，NetworkSettings类型的作用是描述容器的网络具体信息，定义位于<a href="https://github.com/docker/docker/blob/v1.2.0/daemon/network_settings.go#L11-L18">./docker/daemon/network_settings.go#L11-L18</a>，代码如下：</p>
<pre><code>    type NetworkSettings struct {
            IPAddress   string
            IPPrefixLen int
            Gateway     string
            Bridge      string
            PortMapping map\[string\]PortMapping // Deprecated
            Ports       nat.PortMap
    }
</code></pre>
<p>Networksettings类型的各属性的详细解释如下表：</p>
<p><a href="https://res.cloudinary.com/feesuper/image/upload/v1604132962/sel%E5%AE%9E%E9%AA%8C%E5%AE%A4%E5%8D%9A%E5%AE%A2/blogs/537/CONTAINER4_wzxkrl.png"><img src="https://res.cloudinary.com/feesuper/image/upload/v1604132962/sel%E5%AE%9E%E9%AA%8C%E5%AE%A4%E5%8D%9A%E5%AE%A2/blogs/537/CONTAINER4_wzxkrl.png" alt="26"></a></p>
<p>总结而言，Docker Daemon关于create container请求的执行，先实现了容器配置信息从Docker Client至Docker Daemon的转移，再完成了启动容器前所需的准备工作。</p>
<h3 id="22启动容器之网络配置"><strong>2.2启动容器之网络配置</strong></h3>
<p>创建容器阶段，Docker Daemon创建了容器对象container，container对象内部的Config属性含有NetworkDisabled。创建容器完成之后，Docker Daemon还需要接收Docker Client的请求，并执行start container的操作，即启动容器。 启动容器过程中，Docker Daemon首先通过runconfig包中ContainerHostConfigFromJob函数，解析出请求中的hostConfig对象，解析过程代码如下：</p>
<pre><code>    hostConfig := runconfig.ContainerHostConfigFromJob(job) 
</code></pre>
<p>至此，Docker Client处理得到的hostConfig对象，已经传递至Docker Daemon的hostConfig对象，hostConfig对象中已经含有属性NetworkMode具体值。 容器启动的所有工作，均由以下的Start函数来完成，代码位于<a href="https://github.com/docker/docker/blob/v1.2.0/daemon/start.go#L36-L38">./docker/daemon/start.go#L36-L38</a>，如下：</p>
<pre><code>    if err := container.Start(); err != nil {
            return job.Errorf(&quot;Cannot start container %s: %s&quot;, name, err)
    }
</code></pre>
<p>Start函数实现了容器的启动。更为具体的描述是：Start函数实现了进程的启动，另外在启动进程的同时为进程设定了命名空间（namespace），启动完毕之后为进程完成了资源使用的控制，从而保证进程以及之后进程的子进程都会在同一个命名空间内，且受到相同的资源控制。如此一来，Start函数创建的进程，以及该进程的子进程，形成一个进程组，该进程组处于资源隔离和资源控制的环境，我们习惯将这样的进程组环境称为容器，也就是这里的Docker Container。 回到Start函数的执行，位于<a href="https://github.com/docker/docker/blob/v1.2.0/daemon/container.go#L275-L320">./docker/daemon/container.go#L275-L320</a>。Start函数执行过程中，与Docker Container网络模式相关的部分主要有三部分：</p>
<ul>
<li>initializeNetwork()，初始化container对象中与网络相关的属性；</li>
<li>populateCommand，填充Docker Container内部需要执行的命令，Command中含有进程启动命令，还含有容器环境的配置信息，也包括网络配置；</li>
<li>container.waitForStart()，实现Docker Container内部进程的启动，进程启动之后，为进程创建网络环境等。</li>
</ul>
<h4 id="221初始化容器网络配置"><strong>2.2.1初始化容器网络配置</strong></h4>
<p>容器对象container中有属性hostConfig，属性hostConfig中有属性NetworkMode，初始化容器网络配置initializeNetworking()的主要工作就是，通过NetworkMode属性为Docker Container的网络作相应的初始化配置工作。 Docker Container的网络模式有四种，分别为：host、other container、none以及bridge。initializeNetworking函数的执行完全覆盖了这四种模式。 initializeNetworking()函数的实现位于<a href="https://github.com/docker/docker/blob/v1.2.0/daemon/container.go#L881-L933">./docker/daemon/container.go#L881-L933</a>。</p>
<h5 id="2211-初始化host网络模式配置"><strong>2.2.1.1 初始化host网络模式配置</strong></h5>
<p>Docker Container网络的host模式意味着容器使用宿主机的网络环境。虽然Docker Container使用宿主机的网络环境，但这并不代表Docker Container可以拥有宿主机文件系统的视角，而host宿主机上有很多信息标识的是网络信息，故Docker Daemon需要将这部分标识网络的信息，从host宿主机添加到Docker Container内部的指定位置。这样的网络信息，主要有以下两种：</p>
<ul>
<li>host宿主机的主机名（hostname）；</li>
<li>host宿主机上/etc/hosts文件，用于配置IP地址以及主机名。</li>
</ul>
<p>其中，宿主机的主机名hostname用于创建container.Config中的Hostname与Domainname属性。 另外，Docker Daemon在Docker Container的rootfs内部创建hostname文件，并在文件中写入Hostname与Domainname；同时创建hosts文件，并写入host宿主机上/etc/hosts内的所有内容。</p>
<h5 id="2212-初始化other-container网络模式配置"><strong>2.2.1.2 初始化other container网络模式配置</strong></h5>
<p>Docker Container的other container网络模式意味着：容器使用其他已经创建容器的网络环境。 Docker Daemon首先判断host网络模式之后，若不为host网络模式，则继续判断Docker Container网络模式是否为other container。如果Docker Container的网络模式为other container（假设使用的-net参数为&ndash;net=container:17adef，其中17adef为容器ID）。Docker Daemon所做的执行操作包括两部分。 第一步，从container对象的hostConfig属性中找出NetworkMode，并找到相应的容器，即17adef的容器对象container，实现代码如下：</p>
<pre><code>    nc, err := container.getNetworkedContainer()
</code></pre>
<p>第二步，将17adef容器对象的HostsPath、ResolveConfPath、Hostname和Domainname赋值给当前容器对象container，实现代码如下：</p>
<pre><code>    container.HostsPath = nc.HostsPath
    container.ResolvConfPath = nc.ResolvConfPath
    container.Config.Hostname = nc.Config.Hostname
    container.Config.Domainname = nc.Config.Domainname
</code></pre>
<h5 id="2213-初始化none网络模式配置"><strong>2.2.1.3 初始化none网络模式配置</strong></h5>
<p>Docker Container的none网络模式意味着不给该容器创建任何网络环境，容器只能使用127.0.0.1的本机网络。 Docker Daemon通过config属性的DisableNetwork来判断是否为none网络模式。实现代码如下：</p>
<pre><code>    if container.daemon.config.DisableNetwork {
            container.Config.NetworkDisabled = true
            return container.buildHostnameAndHostsFiles(&quot;127.0.1.1&quot;)
    }
</code></pre>
<h5 id="2214-初始化bridge网络模式配置"><strong>2.2.1.4 初始化bridge网络模式配置</strong></h5>
<p>Docker Container的bridge网络模式意味着为容器创建桥接网络模式。桥接模式使得Docker Container创建独立的网络环境，并通过“桥接”的方式实现Docker Container与外界的网络通信。 初始化bridge网络模式的配置，实现代码如下：</p>
<pre><code>    if err := container.allocateNetwork(); err != nil {
            return err
    }
</code></pre>
<p>return container.buildHostnameAndHostsFiles(container.NetworkSettings.IPAddress)</p>
<p>以上代码完成的内容主要也是两部分：第一，通过allocateNetwork函数为容器分配网络接口设备需要的资源信息（包括IP、bridge、Gateway等），并赋值给container对象的NetworkSettings；第二，为容器创建hostname以及创建Hosts等文件。</p>
<h4 id="222创建容器command信息"><strong>2.2.2创建容器Command信息</strong></h4>
<p>Docker在实现容器时，使用了Command类型。Command在Docker Container概念中是一个非常重要的概念。几乎可以认为Command是Docker Container生命周期的源头。Command的概念会贯穿以后的《Docker源码分析》系列，比如Docker Daemon与dockerinit的关系，dockerinit和entrypoint.sh的关系，entrypoint.sh与CMD的关系，以及namespace在这些内容中扮演的角色。 简单来说，Command类型包含了两部分的内容：第一，运行容器内进程的外部命令exec.Cmd；第二，运行容器时启动进程需要的所有环境基础信息：包括容器进程组的使用资源、网络环境、使用设备、工作路径等。通过这两部分的内容，我们可以清楚，如何启动容器内的进程，同时也清楚为容器创建什么样的环境。 首先，我们先来看Command类型的定义，位于<a href="https://github.com/docker/docker/blob/v1.2.0/daemon/execdriver/driver.go#L84">./docker/daemon/execdriver/driver.go#L84</a>，通过分析Command类型以及其他相关的数据结构类型，可以得到以下简要类型关系图：</p>
<p><a href="https://res.cloudinary.com/feesuper/image/upload/v1604132969/sel%E5%AE%9E%E9%AA%8C%E5%AE%A4%E5%8D%9A%E5%AE%A2/blogs/537/CONTAINER5_koifhh.jpg"><img src="https://res.cloudinary.com/feesuper/image/upload/v1604132969/sel%E5%AE%9E%E9%AA%8C%E5%AE%A4%E5%8D%9A%E5%AE%A2/blogs/537/CONTAINER5_koifhh.jpg" alt="27"></a></p>
<p>图 2.1 Command类型关系图</p>
<p>从Command类型关系图中可以看到，Command类型中重新包装了exec.Cmd类型，即代表需要创建的进程具体的外部命令；同时，关于网络方面的属性有Network，Network的类型为指向Network类型的指针；关于Docker Container资源使用方面的属性为Resources，从Resource的类型来看，Docker目前能做的资源限制有4个维度，分别为内存，内存+Swap，CPU使用，CPU核使用；关于挂载的内容，有属性Mounts；等等。</p>
<p>简单介绍Command类型之后，回到Docker Daemon启动容器网络的源码分析。在Start函数的执行流程中，紧接initializeNetworking()之后，与Docker Container网络相关的是populateCommand环节。populateCommand的函数实现位于<a href="https://github.com/docker/docker/blob/v1.2.0/daemon/container.go#L191-L273">./docker/daemon/container.go#L191-L274</a>。</p>
<p>上文已经提及，populateCommand的作用是创建包execdriver的对象Command，该Command中既有启动容器进程的外部命令，同时也有众多为容器环境的配置信息，包括网络。 本小节，更多的分析populateCommand如何填充Command对象中的网络信息，其他信息的分析会在《源码分析系列》的后续进行展开。 Docker总共有四种网络模式，故populateCommand自然需要判断容器属于哪种网络模式，随后将具体的网络模式信息，写入Command对象的Network属性中。查验Docker Container网络模式的代码位于<a href="https://github.com/docker/docker/blob/v1.2.0/daemon/container.go#L204-L227">./docker/daemon/container.go#L204-L227</a>，如下：</p>
<pre><code>    parts := strings.SplitN(string(c.hostConfig.NetworkMode), &quot;:&quot;, 2)
        switch parts[0] {
        case &quot;none&quot;:
        case &quot;host&quot;:
            en.HostNetworking = true
        case &quot;bridge&quot;, &quot;&quot;: // empty string to support existing containers
            if !c.Config.NetworkDisabled {
                network := c.NetworkSettings
                en.Interface = &amp;execdriver.NetworkInterface{
                    Gateway:     network.Gateway,
                    Bridge:      network.Bridge,
                    IPAddress:   network.IPAddress,
                    IPPrefixLen: network.IPPrefixLen,
                }
            }
        case &quot;container&quot;:
            nc, err := c.getNetworkedContainer()
            if err != nil {
                return err
            }
            en.ContainerID = nc.ID
        default:
            return fmt.Errorf(&quot;invalid network mode: %s&quot;, c.hostConfig.NetworkMode)
        }
</code></pre>
<p>populateCommand首先通过hostConfig对象中的NetworkMode判断容器属于哪种网络模式。该部分内容涉及到execdriver包中的Network类型，可参见Command类型关系图中的Network类型。若为none模式，则对于Network对象（即en，*execdriver.Network）不做任何操作。若为host模式，则将Network对象的HostNetworking置为true；若为bridge桥接模式，则首先创建一个NetworkInterface对象，完善该对象的Gateway、Bridge、IPAddress和IPPrefixLen信息，最后将NetworkInterface对象作为Network对象的Interface属性的值；若为other container模式，则首先通过getNetworkedContainer()函数获知被分享网络命名空间的容器，最后将容器ID，赋值给Network对象的ContainerID。</p>
<p>由于bridge模式、host模式、none模式以及other container模式彼此互斥，故Network对象中Interface属性、ContainerID属性以及HostNetworking三者之中只有一个被赋值。当Docker Container的网络查验之后，populateCommand将en实例Network属性的值，传递给Command对象。 至此，populateCommand关于网络方面的信息已经完成配置，网络配置信息已经成功赋值于Command的Network属性。。</p>
<h4 id="223启动容器内部进程"><strong>2.2.3启动容器内部进程</strong></h4>
<p>当为容器做好所有的准备与配置之后，Docker Daemon需要真正意义上的启动容器。根据Docker Daemon启动容器流程涉及的Docker模块中可以看到，这样的请求，会被发送至execdriver，再经过libcontainer，最后实现真正启动进程，创建完容器。 回到Docker Daemon的启动容器，daemon包中start函数的最后一步即为执行container.waitForStart()。waitForStart函数的定义位于<a href="https://github.com/docker/docker/blob/v1.2.0/daemon/container.go#L1070-L1082">./docker/daemon/container.go#L1070-L1082</a>，代码如下：</p>
<pre><code>    func (container \*Container) waitForStart() error {
            container.monitor = newContainerMonitor(container, container.hostConfig.RestartPolicy)
            
            select {
            case &lt;-container.monitor.startSignal:
            case err := &lt;-utils.Go(container.monitor.Start):
                return err
            }

            return nil
    }
</code></pre>
<p>以上代码运行过程中首先通过newContainerMonitor返回一个初始化的containerMonitor对象，该对象中带有容器进程的重启策略（RestartPolicy）。这里简单介绍containerMonitor对象。总体而言，containerMonitor对象用以监视容器中第一个进程的执行。如果containerMonitor中指定了一种进程重启策略，那么一旦容器内部进程没有启动成功，Docker Daemon会使用重启策略来重启容器。如果在重启策略下，容器依然没有成功启动，那么containerMonitor对象会负责重置以及清除所有已经为容器准备好的资源，例如已经为容器分配好的网络资源（即IP地址），还有为容器准备的rootfs等。</p>
<p>waitForStart()函数通过container.monitor.Start来实现容器的启动，进入<a href="https://github.com/docker/docker/blob/v1.2.0/daemon/monitor.go#L100">./docker/daemon/monitor.go#L100</a>，可以发现启动容器进程位于<a href="https://github.com/docker/docker/blob/v1.2.0/daemon/monitor.go#L136">./docker/daemon/monitor.go#L136</a>，代码如下：</p>
<pre><code>    exitStatus, err = m.container.daemon.Run(m.container, pipes, m.callback) 
</code></pre>
<p>以上代码实际调用了daemon包中的Run函数，位于<a href="https://github.com/docker/docker/blob/v1.2.0/daemon/daemon.go#L969-L971">./docker/daemon/daemon.go#L969-L971</a>，代码如下：</p>
<pre><code>    func (daemon *Daemon) Run(c *Container, pipes *execdriver.Pipes, startCallback execdriver.StartCallback) (int, error) {
            return daemon.execDriver.Run(c.command, pipes, startCallback)
    }
</code></pre>
<p>最终，Run函数中调用了execdriver中的Run函数来执行Docker Container的启动命令。 至此，网络部分在Docker Daemon内部的执行已经结束，紧接着程序运行逻辑陷入execdriver，进一步完成容器启动的相关步骤。</p>
<h2 id="3execdriver网络执行流程"><strong>3.execdriver网络执行流程</strong></h2>
<p>Docker架构中execdriver的作用是启动容器内部进程，最终启动容器。目前，在Docker中execdriver作为执行驱动，可以有两种选项：lxc与native。其中，lxc驱动会调用lxc工具实现容器的启动，而native驱动会使用<a href="https://github.com/docker/libcontainer/tree/v1.2.0">Docker官方发布的libcontainer</a>来启动容器。</p>
<p>Docker Daemon启动过程中，execdriver的类型默认为native，故本文主要分析native驱动在执行启动容器时，如何处理网络部分。 在Docker Daemon启动容器的最后一步，即调用了execdriver的Run函数来执行。通过分析Run函数的具体实现，关于Docker Container的网络执行流程主要包括两个环节： (1) 创建libcontainer的Config对象 (2) 通过libcontainer中的namespaces包执行启动容器 将execdriver.Run函数的运行流程具体展开，与Docker Container网络相关的流程，可以得到以下示意图：</p>
<p><a href="https://res.cloudinary.com/feesuper/image/upload/v1604132963/sel%E5%AE%9E%E9%AA%8C%E5%AE%A4%E5%8D%9A%E5%AE%A2/blogs/537/CONTAINER6_hfnxrp.jpg"><img src="https://res.cloudinary.com/feesuper/image/upload/v1604132963/sel%E5%AE%9E%E9%AA%8C%E5%AE%A4%E5%8D%9A%E5%AE%A2/blogs/537/CONTAINER6_hfnxrp.jpg" alt="28"></a></p>
<p>图3.1 execdriver.Run执行流程图</p>
<h3 id="31创建libcontainer的config对象"><strong>3.1创建libcontainer的Config对象</strong></h3>
<p>Run函数位于./docker/daemon/execdriver/native/driver.go#L62-L168，进入Run函数的实现，立即可以发现该函数通过createContainer创建了一个container对象，代码如下：</p>
<pre><code>    container, err := d.createContainer(c) 
</code></pre>
<p>其中c为Docker Daemon创建的execdriver.Command类型实例。以上代码的createContainer函数的作用是：使用execdriver.Command来填充libcontainer.Config。 libcontainer.Config的作用是，定义在一个容器化的环境中执行一个进程所需要的所有配置项。createContainer函数的存在，使用Docker Daemon层创建的execdriver.Command，创建更下层libcontainer所需要的Config对象。这个角度来看，execdriver更像是封装了libcontainer对外的接口，实现了将Docker Daemon认识的容器启动信息转换为底层libcontainer能真正使用的容器启动配置选项。libcontainer.Config类型与其内部对象的关联图如下：</p>
<p><a href="https://res.cloudinary.com/feesuper/image/upload/v1604132963/sel%E5%AE%9E%E9%AA%8C%E5%AE%A4%E5%8D%9A%E5%AE%A2/blogs/537/CONTAINER7_dkgdoe.jpg"><img src="https://res.cloudinary.com/feesuper/image/upload/v1604132963/sel%E5%AE%9E%E9%AA%8C%E5%AE%A4%E5%8D%9A%E5%AE%A2/blogs/537/CONTAINER7_dkgdoe.jpg" alt="29"></a></p>
<p>图3.2 libcontainer.Config类型关系图</p>
<p>进入createContainer的源码实现部分，位于<a href="https://github.com/docker/docker/blob/v1.2.0/daemon/execdriver/native/create.go#L23-L77">./docker/daemon/execdriver/native/create.go#L23-L77</a>，代码如下：</p>
<pre><code>    func (d *driver) createContainer(c *execdriver.Command) (*libcontainer.Config, error) {
        container := template.New()
        ……
        if err := d.createNetwork(container, c); err != nil {
            return nil, err
        }
        ……
        return container, nil
    }
</code></pre>
<h4 id="311-libcontainerconfig模板实例"><strong>3.1.1 libcontainer.Config模板实例</strong></h4>
<p>从createContainer函数的实现以及execdriver.Run执行流程图中都可以看到，createContainer所做的第一个操作就是即为执行template.New()，意为创建一个libcontainer.Config的实例container。其中，template.New()的定义位于<a href="https://github.com/docker/docker/blob/v1.2.0/daemon/execdriver/native/template/default_template.go">./docker/daemon/execdriver/native/template/default_template.go</a>，主要的作用为返回libcontainer关于Docker Container的默认配置选项。 Template.New()的代码实现如下：</p>
<pre><code>    func New() *libcontainer.Config {
        container := &amp;libcontainer.Config{
            Capabilities: []string{
                &quot;CHOWN&quot;,
                &quot;DAC_OVERRIDE&quot;,
                &quot;FSETID&quot;,
                &quot;FOWNER&quot;,
                &quot;MKNOD&quot;,
                &quot;NET_RAW&quot;,
                &quot;SETGID&quot;,
                &quot;SETUID&quot;,
                &quot;SETFCAP&quot;,
                &quot;SETPCAP&quot;,
                &quot;NET_BIND_SERVICE&quot;,
                &quot;SYS_CHROOT&quot;,
                &quot;KILL&quot;,
                &quot;AUDIT_WRITE&quot;,
            },
            Namespaces: map[string]bool{
                &quot;NEWNS&quot;:  true,
                &quot;NEWUTS&quot;: true,
                &quot;NEWIPC&quot;: true,
                &quot;NEWPID&quot;: true,
                &quot;NEWNET&quot;: true,
            },
            Cgroups: &amp;cgroups.Cgroup{
                Parent:          &quot;docker&quot;,
                AllowAllDevices: false,
            },
            MountConfig: &amp;libcontainer.MountConfig{},
        }

        if apparmor.IsEnabled() {
            container.AppArmorProfile = &quot;docker-default&quot;
        }

        return container
    }
</code></pre>
<p>关于该libcontainer.Config默认的模板对象，从源码实现中可以看到，首先设定了Capabilities的默认项，如CHOWN、DAC_OVERRIDE、FSETID等；其次又将Docker Container所需要的设定的namespaces添加默认值，即需要创建5个NAMESPACE，如NEWNS、NEWUTS、NEWIPC、NEWPID和NEWNET，其中不包括user namespace，另外与网络相关的namespace为NEWNET；最后设定了一些关于cgroup以及apparmor的默认配置。 Template.New()函数最后返回类型为libcontainer.Config的实例container，该实例中只含有默认配置项，其他的配置项的添加需要createContainer的后续操作来完成。</p>
<h4 id="312-createnetwork实现"><strong>3.1.2 createNetwork实现</strong></h4>
<p>在createContainer的实现流程中，为了完成container对象（类型为libcontainer.Config）的完善，最后有很多步骤，如与网络相关的createNetwork函数调用，与Linux内核Capabilities相关的setCapabilities函数调用，与cgroups相关的setupCgroups函数调用，以及与挂载目录相关的setupMounts函数调用等。本小节主要分析createNetwork如何为container对象完善网络配置项。 createNetwork函数的定义位于<a href="https://github.com/docker/docker/blob/v1.2.0/daemon/execdriver/native/create.go#L79-L124">./docker/daemon/execdriver/native/create.go#L79-L124</a>，该函数主要利用execdriver.Command中Network属性中的内容，来判断如何创建libcontainer.Config中Network属性（关于两中Network属性，可以参见图3.1和图3.2）。由于Docker Container的4种网络模式彼此互斥，故以上Network类型中Interface、ContainerID与HostNetworking最多只有一项会被赋值。 由于execdriver.Command中Network的类型定义如下：</p>
<pre><code>    type Network struct {
        Interface      *NetworkInterface
        Mtu            int              
        ContainerID    string            
        HostNetworking bool             
    }
</code></pre>
<p>分析createNetwork函数，其具体实现可以归纳为4部分内容： (1) 判断网络是否为host模式； (2) 判断是否为bridge桥接模式； (3) 判断是否为other container模式； (4) 为Docker Container添加loopback网络设备。 首先来看execdriver判断是否为host模式的代码：</p>
<pre><code>    if c.Network.HostNetworking {
        container.Namespaces[&quot;NEWNET&quot;] = false
        return nil
    }
</code></pre>
<p>当execdriver.Command类型实例中Network属性的HostNetworking为true，则说明需要为Docker Container创建host网络模式，使得容器与宿主机共享同样的网络命名空间。关于host模式的具体介绍中，已经阐明，只须在创建进程进行CLONE系统调用时，不传入CLONE_NEWNET参数标志即可实现。这里的代码正好准确的验证了这一点，将container对象中NEWNET的Namespace设为false，最终在libcontainer中可以达到效果。 再看execdriver判断是否为bridge桥接模式的代码：</p>
<pre><code>    if c.Network.Interface != nil {
            vethNetwork := libcontainer.Network{
                Mtu:        c.Network.Mtu,
                Address:    fmt.Sprintf(&quot;%s/%d&quot;, c.Network.Interface.IPAddress, 
    c.Network.Interface.IPPrefixLen),
                Gateway:    c.Network.Interface.Gateway,
                Type:       &quot;veth&quot;,
                Bridge:     c.Network.Interface.Bridge,
                VethPrefix: &quot;veth&quot;,
            }
            container.Networks = append(container.Networks, &amp;vethNetwork)
        }
</code></pre>
<p>当execdriver.Command类型实例中Network属性的Interface不为nil值，则说明需要为Docker Container创建bridge桥接模式，使得容器使用隔离的网络环境。于是这里为类型为libcontainer.Config的container对象添加Networks属性vethNetwork，网络类型为“veth”，以便libcontainer在执行时，可以为Docker Container创建veth pair。 接着来看execdriver判断是否为other container模式的代码：</p>
<pre><code>    if c.Network.ContainerID != &quot;&quot; {
            d.Lock()
            active := d.activeContainers[c.Network.ContainerID]
            d.Unlock()

            if active == nil || active.cmd.Process == nil {
                return fmt.Errorf(&quot;%s is not a valid running container to join&quot;, c.Network.ContainerID)
            }
            cmd := active.cmd

            nspath := filepath.Join(&quot;/proc&quot;, fmt.Sprint(cmd.Process.Pid), &quot;ns&quot;, &quot;net&quot;)
            container.Networks = append(container.Networks, &amp;libcontainer.Network{
                Type:   &quot;netns&quot;,
                NsPath: nspath,
            })
        }
</code></pre>
<p>当execdriver.Command类型实例中Network属性的ContainerID不为空字符串时，则说明需要为Docker Container创建other container模式，使得创建容器使用其他容器的网络环境。实现过程中，execdriver需要首先在activeContainers中查找需要被共享网络环境的容器active；并通过active容器的启动执行命令cmd找到容器第一进程在宿主机上的PID；随后在proc文件系统中找到该进程PID的关于网络namespace的路径nspath；最后为类型为libcontainer.Config的container对象添加Networks属性，Network的类型为“netns”。 此外，createNetwork函数还实现为Docker Container创建一个loopback回环设备，以便容器可以实现内部通信。实现过程中，同样为类型libcontainer.Config的container对象添加Networks属性，Network的类型为“loopback”，代码如下：</p>
<pre><code>    container.Networks = []*libcontainer.Network{
            {
                Mtu:     c.Network.Mtu,
                Address: fmt.Sprintf(&quot;%s/%d&quot;, &quot;127.0.0.1&quot;, 0),
                Gateway: &quot;localhost&quot;,
                Type:    &quot;loopback&quot;,
            },
        }
</code></pre>
<p>至此，createNetwork函数已经把与网络相关的配置，全部创建在类型为libcontainer.Config的container对象中了，就等着启动容器进程时使用。</p>
<h3 id="32-调用libcontainer的namespaces启动容器"><strong>3.2 调用libcontainer的namespaces启动容器</strong></h3>
<p>回到execdriver.Run函数，创建完libcontainer.Config实例container，经过一系列其他方面的处理之后，最终execdriver执行namespaces.Exec函数实现启动容器，container对象依然是namespace.Exec函数中一个非常重要的参数。这一环节代表着execdriver把启动Docker Container的工作交给libcontainer，以后的执行陷入libcontainer。 调用namespaces.Exec的代码位于<a href="https://github.com/docker/docker/blob/v1.2.0/daemon/execdriver/native/driver.go#L102-L127">./docker/daemon/execdriver/native/driver.go#L102-L127</a>，为了便于理解，简化的代码如下：</p>
<pre><code>    namespaces.Exec(container, c.Stdin, c.Stdout, c.Stderr, c.Console,
    c.Rootfs, dataPath, args, parameter_1, parameter_2)
</code></pre>
<p>其中parameter_1为定义的函数，如下：</p>
<pre><code>    func(container *libcontainer.Config, console, rootfs, dataPath, 
    init string, child *os.File, args []string) *exec.Cmd {
            c.Path = d.initPath
            c.Args = append([]string{
                DriverName,
                &quot;-console&quot;, console,
                &quot;-pipe&quot;, &quot;3&quot;,
                &quot;-root&quot;, filepath.Join(d.root, c.ID),
                &quot;--&quot;,
            }, args...)

            // set this to nil so that when we set the clone flags anything else is reset
            c.SysProcAttr = &amp;syscall.SysProcAttr{
                Cloneflags: uintptr(namespaces.GetNamespaceFlags(container.Namespaces)),
            }
            c.ExtraFiles = []*os.File{child}

            c.Env = container.Env
            c.Dir = c.Rootfs

            return &amp;c.Cmd
        }
</code></pre>
<p>同样的，parameter_2也为定义的函数，如下：</p>
<pre><code>    func() {
            if startCallback != nil {
                c.ContainerPid = c.Process.Pid
                startCallback(c)
            }
        }
</code></pre>
<p>Parameter_1以及parameter_2这两个函数均会在libcontainer的namespaces中发挥很大的重要。 至此，execdriver模块的执行部分已经完结，Docker Daemon的程序运行逻辑陷入libcontainer。</p>
<h2 id="4libcontainer实现内核态网络配置"><strong>4.libcontainer实现内核态网络配置</strong></h2>
<p>libcontainer是一个Linux操作系统上容器的实现包。libcontainer指定了创建一个容器时所需要的配置选项，同时它利用Linux namespace和cgroup等技术为使用者提供了一套Golang原生态的容器实现方案，并且没有使用任何外部依赖。用户借助libcontainer，可以感受到众多操纵namespaces，网络等资源的便利。 当execdriver调用libcontainer中namespaces包的Exec函数时，libcontainer开始发挥其实现容器功能的作用。Exec函数位于<a href="https://github.com/docker/libcontainer/blob/v1.2.0/namespaces/exec.go#L24-L113">./libcontainer/namespaces/exec.go#L24-L113</a>。</p>
<p>本文更多的关心Docker Container的网络创建，因此从这个角度来看Exec的实现可以分为三个步骤： (1) 通过createCommand创建一个Golang语言内的exec.Cmd对象； (2) 启动命令exec.Cmd，执行容器内第一个进程； (3) 通过InitializeNetworking函数为容器进程初始化网络环境。 以下详细分析这三个部分，源码的具体实现。</p>
<h3 id="41创建execcmd"><strong>4.1创建exec.Cmd</strong></h3>
<p>提到exec.Cmd，就不得不提Go语言标准库中的包os以及包os/exec。前者提供了与平台无关的操作系统功能集，后者则提供了功能集里与命令执行相关的部分。 首先来看一下在Go语言中exec.Cmd的定义，如下：</p>
<pre><code>    type Cmd struct {
            Path string                   //所需执行命令在系统中的路径
            Args []string                  //传入命令的参数
            Env []string                   //进程运行时的环境变量
            Dir string                     //命令运行的工作目录
            Stdin io.Reader
            Stdout io.Writer
            Stderr io.Writer
            ExtraFiles []*os.File             //进程所需打开的文件描述符资源
            SysProcAttr *syscall.SysProcAttr   //可选的操作系统属性
            Process *os.Process            //代表Cmd启动后，操作系统底层的具体进程
            ProcessState *os.ProcessState    //进程退出后保留的信息
    }
</code></pre>
<p>清楚Cmd的定义之后，再来分析namespaces包的Exec函数中，是如何来创建exec.Cmd的。在Exec函数的实现过程中，使用了以下代码实现Exec.Cmd的创建：</p>
<pre><code>    command := createCommand(container, console, rootfs, dataPath, 
    os.Args[0], syncPipe.Child(), args) 
</code></pre>
<p>其中createCommand为namespace.Exec函数中传入的倒数第二个参数，类型为CreateCommand。而createCommand只是namespaces.Exec函数的形参，真正的实参则为execdriver调用namespaces.Exec时的参数parameter_1，即如下代码：</p>
<pre><code>    func(container *libcontainer.Config, console, rootfs, dataPath,
    init string, child *os.File, args []string) *exec.Cmd {
            c.Path = d.initPath
            c.Args = append([]string{
                DriverName,
                &quot;-console&quot;, console,
                &quot;-pipe&quot;, &quot;3&quot;,
                &quot;-root&quot;, filepath.Join(d.root, c.ID),
                &quot;--&quot;,
            }, args...)

            // set this to nil so that when we set the clone flags anything else is reset
            c.SysProcAttr = &amp;syscall.SysProcAttr{
                Cloneflags: uintptr(namespaces.GetNamespaceFlags(container.Namespaces)),
            }
            c.ExtraFiles = []*os.File{child}

            c.Env = container.Env
            c.Dir = c.Rootfs

            return &amp;c.Cmd
        }
</code></pre>
<p>熟悉exec.Cmd的定义之后，分析以上代码的实现就显得较为简单。为Cmd赋值的对象有Path，Args，SysProcAttr，ExtraFiles，Env和Dir。其中需要特别注意的是Path的值d.initPath，该路径下存放的是dockerinit的二进制文件，Docker 1.2.0版本下，路径一般为“/var/lib/docker/init/dockerinit-1.2.0”。另外SysProcAttr使用以下的代码来赋值：</p>
<pre><code>    &amp;syscall.SysProcAttr{
            Cloneflags: uintptr(namespaces.GetNamespaceFlags(container.Namespaces)),
        }
</code></pre>
<p>syscall.SysProAttr对象中的Cloneflags属性中，即保留了libcontainer.Config类型的实例container中的Namespace属性。换言之，通过exec.Cmd创建进程时，正是通过Cloneflags实现Clone系统调用中传入namespace参数标志。 回到函数执行中，在函数的最后返回了c.Cmd，命令创建完毕。</p>
<h3 id="42启动execcmd创建进程"><strong>4.2启动exec.Cmd创建进程</strong></h3>
<p>创建完exec.Cmd，当然需要将该执行命令运行起来，namespaces.Exec函数中直接使用以下代码实现进程的启动：</p>
<pre><code>    if err := command.Start(); err != nil {
            return -1, err
        }
</code></pre>
<p>这一部分的内容简单直接， Start()函数用以完成指定命令exec.Cmd的启动执行，同时并不等待其启动完毕便返回。Start()函数的定义位于os/exec包。 进入os/exec包，查看Start()函数的实现，可以看到执行过程中，会对command.Process进行赋值，此时command.Process中会含有刚才启动进程的PID进程号，该PID号属于在宿主机pid namespace下，而并非是新创建namespace下的PID号。</p>
<h3 id="43为容器进程初始化网络环境"><strong>4.3为容器进程初始化网络环境</strong></h3>
<p>上一环节实现了容器进程的启动，然而却还没有为之配置相应的网络环境。namespaces.Exec在之后的InitializeNetworing中实现了为容器进程初始化网络环境。初始化网络环境需要两个非常重要的参数：container对象以及容器进程的Pid号。类型为libcontainer.Config的实例container中包含用户对Docker Container的网络配置需求，另外容器进程的Pid可以使得创建的网络环境与进程新创建的namespace进行关联。 namespaces.Exec中为容器进程初始化网络环境的代码实现位于<a href="https://github.com/docker/libcontainer/blob/v1.2.0/namespaces/exec.go#L75-L79">./libcontainer/namespaces/exec.go#L75-L79</a>，如下：</p>
<pre><code>    if err := InitializeNetworking(container, command.Process.Pid, syncPipe, &amp;networkState); err != nil {
            command.Process.Kill()
            command.Wait()
            return -1, err
        }
</code></pre>
<p>InitializeNetworing的作用很明显，即为创建的容器进程初始化网络环境。更为底层的实现包含两个步骤： (1) 先在容器进程的namespace外部，创建容器所需的网络栈； (2) 将创建的网络栈迁移进入容器的net namespace。 IntializeNetworking的源代码实现位于<a href="https://github.com/docker/libcontainer/blob/v1.2.0/namespaces/exec.go#L176-L187">./libcontainer/namespaces/exec.go#L176-L187</a>，如下：</p>
<pre><code>    func InitializeNetworking(container *libcontainer.Config, nspid int, pipe *syncpipe.SyncPipe, networkState *network.NetworkState) error {
        for _, config := range container.Networks {
            strategy, err := network.GetStrategy(config.Type)
            if err != nil {
                return err
            }
            if err := strategy.Create((*network.Network)(config), nspid, networkState); err != nil {
                return err
            }
        }
        return pipe.SendToChild(networkState)
    }
</code></pre>
<p>以上源码实现过程中，首先通过一个循环，遍历libcontainer.Config类型实例container中的网络属性Networks；随后使用GetStrategy函数处理Networks中每一个对象的Type属性，得出Network的类型，这里的类型有3种，分别为“loopback”、“veth”、“netns”。除host网络模式之外，loopback对于其他每一种网络模式的Docker Container都需要使用；veth针对bridge桥接模式，而netns针对other container模式。 得到Network类型的类型之后，libcontainer创建相应的网络栈，具体实现使用每种网络栈类型下的Create函数。以下分析三种不同网络栈各自的创建流程。</p>
<h4 id="431-loopback网络栈的创建"><strong>4.3.1 loopback网络栈的创建</strong></h4>
<p>Loopback是一种本地环回设备，libcontainer创建loopback网络设备的实现代码位于<a href="https://github.com/docker/libcontainer/blob/v1.2.0/network/loopback.go#L13-L15">./libcontainer/network/loopback.go#L13-L1</a>，如下：</p>
<pre><code>    func (l *Loopback) Create(n *Network, nspid int, networkState *NetworkState) error {
            return nil
    }
</code></pre>
<p>令人费解的是，libcontainer在loopback设备的创建函数Create中，并没有作实质性的内容，而是直接返回nil。 其实关于loopback设备的创建，要回到Linux内核为进程新建namespace的阶段。当libcontainer执行command.Start()时，由于创建了一个新的网络namespace，故Linux内核会自动为新的net namespace创建loopback设备。当Linux内核创建完loopback设备之后，libcontainer所做的工作即只要保留loopback设备的默认配置，并在Initialize函数中实现启动该设备。</p>
<h4 id="432-veth网络栈的创建"><strong>4.3.2 veth网络栈的创建</strong></h4>
<p>Veth是Docker Container实际使用的网络策略之一，其使用网桥docker0并创建veth pair虚拟网络设备对，最终使一个veth配置在宿主机上，而另一个veth安置在容器网络namespace内部。 libcontainer中实现veth策略的代码非常通俗易懂，代码位于<a href="https://github.com/docker/libcontainer/blob/v1.2.0/network/veth.go#L19-L50">./libcontainer/network/veth.go#L19-L50</a>，如下：</p>
<pre><code>    name1, name2, err := createVethPair(prefix)
        if err != nil {
            return err
        }
        if err := SetInterfaceMaster(name1, bridge); err != nil {
            return err
        }
        if err := SetMtu(name1, n.Mtu); err != nil {
            return err
        }
        if err := InterfaceUp(name1); err != nil {
            return err
        }
        if err := SetInterfaceInNamespacePid(name2, nspid); err != nil {
            return err
        }
</code></pre>
<p>主要的流程包含的四个步骤： (1) 在宿主机上创建veth pair； (2) 将一个veth附加至docker0网桥上； (3) 启动第一个veth； (4) 将第二个veth附加至libcontainer创建进程的namespace下。 使用Create函数实现veth pair的创建之后，在Initialize函数中实现将网络namespace中的veth改名为“eth0”，并设置网络设备的MTU等。</p>
<h4 id="433-netns网络栈的创建"><strong>4.3.3 netns网络栈的创建</strong></h4>
<p>netns专门为Docker Container的other container网络模式服务。netns完成的工作是将其他容器的namespace路径传递给需要创建other container网络模式的容器使用。 libcontainer中实现netns策略的代码位于<a href="https://github.com/docker/libcontainer/blob/v1.2.0/network/netns.go#L17-L20">./libcontainer/network/netns.go#L17-L20</a>，如下：</p>
<pre><code>    func (v *NetNS) Create(n *Network, nspid int, networkState *NetworkState) error {
            networkState.NsPath = n.NsPath
            return nil
    }
</code></pre>
<p>使用Create函数先将NsPath赋给新建容器之后，在Initialize函数中实现将网络namespace的文件描述符交由新创建容器使用，最终实现两个Docker Container共享同一个网络栈。 通过Create以及Initialize的实现之后，Docker Container相应的网络栈环境即已经完成创建，容器内部的应用进程可以使用不同的网络栈环境与外界或者内部进行通信。关于Initialize函数何时被调用，需要清楚Docker Daemon与dockerinit的关系，以及如何实现Docker Daemon进程与dockerinit进程跨namespace进行通信，这部分内容会在《Docker源码分析》系列后续专文分析。</p>
<h2 id="5总结"><strong>5.总结</strong></h2>
<p>如何使用Docker Container的网络，一直是工业界倍加关心的问题。本文将从Linux内核原理的角度阐述了什么是Docker Container，并对Docker Container 4种不同的网络模式进行了初步的介绍，最终贯穿Docker 架构中的多个模块，如Docker Client、Docker Daemon、execdriver以及libcontainer，深入分析Docker Container网络的实现步骤。 目前，若只谈论Docker，那么它还是只停留在单host宿主机的场景上。如何面对跨host的场景、如何实现分布式Docker Container的管理，目前为止还没有一个一劳永逸的解决方案。再者，一个解决方案的存在，总是会适应于一个应用场景。Docker这种容器技术的发展，大大改善了传统模式下使用诸如虚拟机等传统计算单位存在的多数弊端，却在网络方面使得自身的使用过程中存在瑕疵。希望本文是一个引子，介绍Docker Container网络，以及从源码的角度分析Docker Container网络之后，能有更多的爱好者思考Docker Container网络的前世今生，并为Docker乃至容器技术的发展做出贡献。</p>
<h2 id="7参考文献"><strong>7.参考文献</strong></h2>
<p><a href="http://docs.studygolang.com/pkg/os/exec/#Cmd">http://docs.studygolang.com/pkg/os/exec/#Cmd</a></p>
<p><a href="https://github.com/docker/libcontainer/tree/v1.2.0">https://github.com/docker/libcontainer/tree/v1.2.0</a></p>
<p><a href="https://github.com/docker/libcontainer/issues/323">https://github.com/docker/libcontainer/issues/323</a></p>

                        </div>
                        
                        
                        
                        
                        
                        <div id="SOHUCS"></div>
                        <script charset="utf-8" type="text/javascript" src="https://cy-cdn.kuaizhan.com/upload/changyan.js" ></script>
                        <script type="text/javascript">
                          window.changyan.api.config({
                          appid: 'cyuX8hDAj',
                          conf: 'prod_4e1f40d37469ca7d81688963c063f0f7'
                          });
                        </script>

                    </div>
                    

                    

                    

                    <div class="col-md-3">

                        

                        

<div class="panel panel-default sidebar-menu">

    <div class="panel-heading">
      <h3 class="panel-title">搜索栏</h3>
      
    </div>

    <div class="panel-body">
        
        <div class="search" id="search">
            <div class="input-group">
                <input type="text" name="q" class="form-control" placeholder="请输入文章标题或摘要..." id="search-key">
                <input type="hidden" name="sitesearch" value="https://Rachel-Shao.github.io/">
                <span class="input-group-btn">
                    <button type="submit" class="btn btn-template-main" onclick="search()"><i class="fas fa-search"></i></button>
                </span>
            </div>
            <h1 id="search-tip" style="color: red;text-align: center;display: none;font-size: medium;">搜索中，请稍后 ...</h1>
        </div>
        <script type="text/javascript">
            
            window.onload = function() {
                      document.onkeydown = function(ev) {
                        var event = ev || event
                        if (event.keyCode == 13) {
                          search()
                        }
                      }
                    }
            
            function search() {
                      key = document.getElementById("search-key").value;
                      if (key === "") {
                        
                        return;
                      }
                      document.getElementById("search-key").value = "";
                  
                      
                      document.getElementById("search-tip").innerText = "搜索中，请稍后 ...";
                      document.getElementById("search-tip").style.display = "block";
                  
                      
                      var el = document.getElementById('blog-listing-medium');
                      var childs = el.childNodes;
                      for (var i = childs.length - 1; i >= 0; i--) {
                        el.removeChild(childs[i]);
                      }
                  
                      
                      xmltext = new XMLHttpRequest;
                      xmltext.open("GET", "/index.xml", false);
                      xmltext.send();
                      resp = xmltext.responseXML;
                      items = resp.getElementsByTagName("item");
                      
                      var i = 0;
                      haveResult = false;
                      while (i < items.length) {
                        txt = items[i].getElementsByTagName("title")[0].innerHTML + items[i].getElementsByTagName("description")[0].innerHTML
                        if (txt.indexOf(key) > -1) {
                          haveResult = true;
                          title = items[i].getElementsByTagName("title")[0].innerHTML;
                          link = items[i].getElementsByTagName("link")[0].innerHTML;
                          time = items[i].getElementsByTagName("pubDate")[0].innerHTML;
                          mark = items[i].getElementsByTagName("description")[0].innerHTML;
                          addItem(title, link, time, mark)
                        }
                        i++;
                      }
                      if (!haveResult) {
                        document.getElementById("search-tip").innerText = "搜索完毕，未发现结果 ...";
                        document.getElementById("search-tip").style.display = "block";
                      }
                    }
                  
                    
                    function addItem(title, link, time, mark) {
                      document.getElementById("search-tip").style.display = "none";
                      tmpl = "<article class=\"post\" style=\"border-bottom: 1px solid #e6e6e6;\" >" +
                        "<header class=\"post-header\">" +
                        "<h1 class=\"post-title\"><a class=\"post-link\" href=\"" + link + "\" target=\"_blank\">" + title + "</a></h1>" +
                        "<div class=\"post-meta\">" +
                        " <span class=\"post-time\">" + time + "</span>" +
                        "</div>" +
                        " </header>" +
                        "<div class=\"post-content\">" +
                        "<div class=\"post-summary\">" + mark + "</div>" +
                        "<div class=\"read-more\">" +
                        "<a href=" + link + " class=\"read-more-link\" target=\"_blank\">阅读更多</a>" +
                        "</div>" +
                        " </div>" +
                        "</article>"
                      div = document.createElement("div")
                      div.innerHTML = tmpl;
                      document.getElementById('blog-listing-medium').appendChild(div)
                    }

        </script>
        
    </div>
</div>







<div class="panel panel-default sidebar-menu">

    <div class="panel-heading">
        <h3 class="panel-title">归档栏</h3>
        
    </div>

    <div class="panel-body">
        <ul class="nav nav-pills nav-stacked">
            
            
            <li>
                <a href="/categories/cloudfoundry">cloudfoundry (12)</a>
            </li>
            
            <li>
                <a href="/categories/contaienrd">contaienrd (1)</a>
            </li>
            
            <li>
                <a href="/categories/docker">docker (12)</a>
            </li>
            
            <li>
                <a href="/categories/kubernetes">kubernetes (1)</a>
            </li>
            
            <li>
                <a href="/categories/network">network (1)</a>
            </li>
            
        </ul>
    </div>

</div>








<div class="panel sidebar-menu">

    <div class="panel-heading">
        <h3 class="panel-title">标签栏</h3>
        
    </div>

    <div class="panel-body">
        <ul class="tag-cloud">
            
            
            <li>
                <a href="/tags/agent"><i class="fas fa-tags"></i> agent</a>
            </li>
            
            <li>
                <a href="/tags/apiserver"><i class="fas fa-tags"></i> apiserver</a>
            </li>
            
            <li>
                <a href="/tags/books"><i class="fas fa-tags"></i> books</a>
            </li>
            
            <li>
                <a href="/tags/bosh"><i class="fas fa-tags"></i> bosh</a>
            </li>
            
            <li>
                <a href="/tags/ccng"><i class="fas fa-tags"></i> ccng</a>
            </li>
            
            <li>
                <a href="/tags/cf-release"><i class="fas fa-tags"></i> cf-release</a>
            </li>
            
            <li>
                <a href="/tags/cgroups"><i class="fas fa-tags"></i> cgroups</a>
            </li>
            
            <li>
                <a href="/tags/cloud_controller_ng"><i class="fas fa-tags"></i> cloud_controller_ng</a>
            </li>
            
            <li>
                <a href="/tags/cloudfoundry"><i class="fas fa-tags"></i> cloudfoundry</a>
            </li>
            
            <li>
                <a href="/tags/cloudnative"><i class="fas fa-tags"></i> cloudnative</a>
            </li>
            
            <li>
                <a href="/tags/collector"><i class="fas fa-tags"></i> collector</a>
            </li>
            
            <li>
                <a href="/tags/containerd"><i class="fas fa-tags"></i> containerd</a>
            </li>
            
            <li>
                <a href="/tags/cri"><i class="fas fa-tags"></i> cri</a>
            </li>
            
            <li>
                <a href="/tags/dea"><i class="fas fa-tags"></i> dea</a>
            </li>
            
            <li>
                <a href="/tags/docker"><i class="fas fa-tags"></i> docker</a>
            </li>
            
            <li>
                <a href="/tags/docker-network"><i class="fas fa-tags"></i> docker-network</a>
            </li>
            
            <li>
                <a href="/tags/edgecomputing"><i class="fas fa-tags"></i> edgecomputing</a>
            </li>
            
            <li>
                <a href="/tags/etcd"><i class="fas fa-tags"></i> etcd</a>
            </li>
            
            <li>
                <a href="/tags/gorouter"><i class="fas fa-tags"></i> gorouter</a>
            </li>
            
            <li>
                <a href="/tags/haproxy"><i class="fas fa-tags"></i> haproxy</a>
            </li>
            
            <li>
                <a href="/tags/healthmanager"><i class="fas fa-tags"></i> healthmanager</a>
            </li>
            
            <li>
                <a href="/tags/istio"><i class="fas fa-tags"></i> istio</a>
            </li>
            
            <li>
                <a href="/tags/kubeedge"><i class="fas fa-tags"></i> kubeedge</a>
            </li>
            
            <li>
                <a href="/tags/kubelet"><i class="fas fa-tags"></i> kubelet</a>
            </li>
            
            <li>
                <a href="/tags/kubernetes"><i class="fas fa-tags"></i> kubernetes</a>
            </li>
            
            <li>
                <a href="/tags/libcontainer"><i class="fas fa-tags"></i> libcontainer</a>
            </li>
            
            <li>
                <a href="/tags/micro-service"><i class="fas fa-tags"></i> micro-service</a>
            </li>
            
            <li>
                <a href="/tags/namespace"><i class="fas fa-tags"></i> namespace</a>
            </li>
            
            <li>
                <a href="/tags/nats"><i class="fas fa-tags"></i> nats</a>
            </li>
            
            <li>
                <a href="/tags/news"><i class="fas fa-tags"></i> news</a>
            </li>
            
            <li>
                <a href="/tags/pipework"><i class="fas fa-tags"></i> pipework</a>
            </li>
            
            <li>
                <a href="/tags/pouch"><i class="fas fa-tags"></i> pouch</a>
            </li>
            
            <li>
                <a href="/tags/runc"><i class="fas fa-tags"></i> runc</a>
            </li>
            
            <li>
                <a href="/tags/runtime"><i class="fas fa-tags"></i> runtime</a>
            </li>
            
            <li>
                <a href="/tags/security"><i class="fas fa-tags"></i> security</a>
            </li>
            
            <li>
                <a href="/tags/serverless"><i class="fas fa-tags"></i> serverless</a>
            </li>
            
            <li>
                <a href="/tags/service-mesh"><i class="fas fa-tags"></i> service-mesh</a>
            </li>
            
            <li>
                <a href="/tags/syslog_aggregator"><i class="fas fa-tags"></i> syslog_aggregator</a>
            </li>
            
        </ul>
    </div>

</div>






                        

                    </div>
                    

                    

                </div>
                

            </div>
            
        </div>
        

        <footer id="footer">
    <div class="container">

        
        <div class="col-md-4 col-sm-6">
            <h4></h4>

            <p><strong>关于我们：<strong> <p>浙大SEL实验室</p><p>地址：杭州市浙大路38号曹光彪西楼405室</p><p><strong></strong>
            <a href="/contact" class="btn btn-small btn-template-main" >跳转到关于</a>

            <hr class="hidden-md hidden-lg hidden-sm">

        </div>
        
        

        <div class="col-md-4 col-sm-6">

             
            <h4>最新博客</h4>
            

            <div class="blog-entries">
                
                <div class="item same-height-row clearfix">
                    <div class="image same-height-always">
                        <a href="https://Rachel-Shao.github.io/blog/2018/11/29/kubeedge%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97%E4%B8%80%E6%80%BB%E4%BD%93%E6%9E%B6%E6%9E%84%E5%88%86%E6%9E%90/">
                          
                            <img src="/img/placeholder.png" class="img-responsive" alt="kubeedge源码分析系列一：总体架构分析">
                          
                        </a>
                    </div>
                    <div class="name same-height-always">
                        <h5><a href="https://Rachel-Shao.github.io/blog/2018/11/29/kubeedge%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97%E4%B8%80%E6%80%BB%E4%BD%93%E6%9E%B6%E6%9E%84%E5%88%86%E6%9E%90/">kubeedge源码分析系列一：总体架构分析</a></h5>
                    </div>
                </div>
                
                <div class="item same-height-row clearfix">
                    <div class="image same-height-always">
                        <a href="https://Rachel-Shao.github.io/blog/2018/10/11/knative-serving%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/">
                          
                            <img src="/img/placeholder.png" class="img-responsive" alt="knative serving开发环境搭建">
                          
                        </a>
                    </div>
                    <div class="name same-height-always">
                        <h5><a href="https://Rachel-Shao.github.io/blog/2018/10/11/knative-serving%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/">knative serving开发环境搭建</a></h5>
                    </div>
                </div>
                
                <div class="item same-height-row clearfix">
                    <div class="image same-height-always">
                        <a href="https://Rachel-Shao.github.io/blog/2018/08/05/%E4%BB%8Econtaienrd-pull%E9%95%9C%E5%83%8F%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90oci-distribution-spec/">
                          
                            <img src="/img/blogs/921/dockerarchitecture.png" class="img-responsive" alt="从contaienrd pull镜像流程分析oci distribution spec">
                          
                        </a>
                    </div>
                    <div class="name same-height-always">
                        <h5><a href="https://Rachel-Shao.github.io/blog/2018/08/05/%E4%BB%8Econtaienrd-pull%E9%95%9C%E5%83%8F%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90oci-distribution-spec/">从contaienrd pull镜像流程分析oci distribution spec</a></h5>
                    </div>
                </div>
                
            </div>

            <hr class="hidden-md hidden-lg">
             

        </div>
        

        
        <div class="col-md-4 col-sm-6">

          <h4></h4>

            <p><strong>联系我们: 
                                    <p>团队负责人：丁轶群 yiqunding@zju.edu.cn</p>
                                    <p>网站维护人：冯志凌 502361391@qq.com</p>                
    </strong>

            

            <hr class="hidden-md hidden-lg hidden-sm">

        </div>
        
        

    </div>
    
</footer>







<div id="copyright">
    <div class="container">
        <div class="col-md-12">
            
            <p class="pull-left">Copyright ©️ 2020 SEL Laboratory , ZJ University all rights reserved.</p>
            
            <p class="pull-right">
               <a href="https://bootstrapious.com/p/universal-business-e-commerce-template">Bootstrapious</a>.
              

               <a href="https://github.com/devcows/hugo-universal-theme">DevCows</a>.
            </p>
        </div>
    </div>
</div>





    </div>
    

    
<script src="//code.jquery.com/jquery-3.1.1.min.js" integrity="sha256-hVVnYaiADRTO2PzUGmuLJr8BLUSjGIZsDYGmIJLv2b8=" crossorigin="anonymous"></script>
<script src="//maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script>

<script src="//cdnjs.cloudflare.com/ajax/libs/jquery-cookie/1.4.1/jquery.cookie.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/waypoints/4.0.1/jquery.waypoints.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/Counter-Up/1.0/jquery.counterup.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/jquery-parallax/1.1.3/jquery-parallax.js"></script>

<script src="/js/front.js"></script>


<script src="/js/owl.carousel.min.js"></script>



  </body>
</html>
