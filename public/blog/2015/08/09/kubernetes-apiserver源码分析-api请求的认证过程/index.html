<!DOCTYPE html>
<html lang="zh-CN">

  <head>
  <meta charset="utf-8">
  <meta name="robots" content="all,follow">
  <meta name="googlebot" content="index,follow,snippet,archive">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  
  <title>kubernetes apiserver源码分析——api请求的认证过程</title>
  <meta name="author" content="浙大SEL实验室" />
  
  
  
  
  <meta name="keywords" content="apiserver, Kubernetes">
  
  
  <meta name="description" content="">

  <meta name="generator" content="Hugo 0.74.2" />

  
  <link href='//fonts.googleapis.com/css?family=Roboto:400,100,100italic,300,300italic,500,700,800' rel='stylesheet' type='text/css'>

  
  <link rel="stylesheet" href="//use.fontawesome.com/releases/v5.11.2/css/all.css">
  <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">

  
  <link href="/css/animate.css" rel="stylesheet">

  
  
    <link href="/css/style.default.css" rel="stylesheet" id="theme-stylesheet">
  

  
  <link href="/css/custom.css" rel="stylesheet">

  
  
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
        <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->
  

  
  <link rel="shortcut icon" href="/img/favicon.ico" type="image/x-icon" />
  <link rel="apple-touch-icon" href="/img/apple-touch-icon.png" />

  
  <link href="/css/owl.carousel.css" rel="stylesheet">
  <link href="/css/owl.theme.css" rel="stylesheet">

  
  <link rel="alternate" href="https://Rachel-Shao.github.io/index.xml" type="application/rss+xml" title="浙大SEL实验室">

  
  
  
  
  
  
  <meta property="og:updated_time" content="2015-08-09T11:25:44Z">
  
    
    
    
    <meta property="article:tag" content="apiserver">
    <meta property="article:tag" content="Kubernetes">
    <meta property="article:tag" content="Kubernetes">
    
    
    <meta property="article:published_time" content="2015-08-09T11:25:44Z">
    <meta property="article:modified_time" content="2015-08-09T11:25:44Z">
  

  
  <meta name="twitter:card" content="summary">
  
  <meta name="twitter:title" content="kubernetes apiserver源码分析——api请求的认证过程">
  
  <meta name="twitter:description" content="">
  

</head>


  <body>

    <div id="all">

        <header class="navbar-affixed-top" data-spy="affix" data-offset-top="62">
    <div class="navbar navbar-default yamm" role="navigation" id="navbar" style="background-color:white;">    
        <div class="container">
            <div class="navbar-header">
                <a class="navbar-brand home" href="/">
                    <img src="/img/sel.png" alt="kubernetes apiserver源码分析——api请求的认证过程" class="hidden-xs hidden-sm img-responsive">
                    
                    <span class="sr-only">kubernetes apiserver源码分析——api请求的认证过程 - </span>
                </a>
                <div class="navbar-buttons">
                    <button type="button" class="navbar-toggle btn-template-main" data-toggle="collapse" data-target="#navigation">
                      <span class="sr-only"></span>
                        <i class="fas fa-align-justify"></i>
                    </button>
                </div>
            </div>
            

            <div class="navbar-collapse collapse" id="navigation">
                <ul class="nav navbar-nav navbar-right">
                  
                  
                  <li class="dropdown">
                    
                    <a href="/">主页</a>
                    
                  </li>
                  
                  <li class="dropdown">
                    
                    <a href="/blog/">博客</a>
                    
                  </li>

                  <li class="dropdown">
                    
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">社区 <span class="caret"></span></a>
                  <ul class="dropdown-menu">
                    
                      <li><a href="https://www.servicemesher.com/">ServiceMesh社区</a></li>
                    
                      <li><a href="">kubeedge社区</a></li>

                      <li><a href="http://www.icsoft.zju.edu.cn/index.php">浙江大学智能计算与软件中心</a></li>
                    
                  </ul>

                  <li class="dropdown">
                    
                    <a href="/archives/">归档</a>
                    
                  </li>
                  
                  <li class="dropdown">
                    
                    <a href="/contact/">关于</a>
                    
                  </li>
                  
                </li>

                
                

                
                </ul>
            </div>
            

            <div class="collapse clearfix" id="search">    
                <form class="navbar-form" role="search">
                    <div class="input-group">
                        <input type="text" class="form-control" placeholder="Search">
                        <span class="input-group-btn">
                    <button type="submit" class="btn btn-template-main"><i class="fas fa-search"></i></button>
                </span>
                    </div>
                </form>
            </div>
            
        </div>
    </div>

    
</header>




        <div id="heading-breadcrumbs">
    <div class="container">
        <div class="row">
            <div class="col-md-12">
                <h1>kubernetes apiserver源码分析——api请求的认证过程</h1>
            </div>
        </div>
    </div>
</div>


        <div id="content">
            <div class="container">

                <div class="row">

                    

                    <div class="col-md-9" id="blog-post">

                        
                          <p class="text-muted text-uppercase mb-small text-right">
                            
                            
                            2015-08-09
                          </p>
                        

                        <div id="post-content">
                          <h2 id="解决什么问题"><strong>解决什么问题</strong></h2>
<p>笔者之前希望全面分析一下k8apiserver的源码，后来发现这样并不十分有效，其一没有针对性，其二由于代码本身比较复杂，涉及到的功能较多，面面俱到也不太现实。 于是我们就回到最初的需求，到底需要解决什么问题，第一个问题就是，apiserver启动的时候，使用secure模式，参数应该如何设置，相关的机制又是怎样？ 这一部分的issue很多，如果不从源码来分析的话，就只能黑盒化的去尝试各种参数搭配，费时费力，也不确定是否正确，之前就是这样，这几个issue可以供参考： <a href="https://github.com/GoogleCloudPlatform/kubernetes/issues/10159#issuecomment-113955582">https://github.com/GoogleCloudPlatform/kubernetes/issues/10159#issuecomment-113955582</a> <a href="https://github.com/GoogleCloudPlatform/kubernetes/issues/11000">https://github.com/GoogleCloudPlatform/kubernetes/issues/11000</a></p>
<h2 id="apiserver启动过程的代码概览"><strong>apiserver启动过程的代码概览</strong></h2>
<p>apiserver相当于是k8集群的一个入口，不论通过kubectl还是使用remote api 直接控制，都要经过apiserver。apiserver说白了就是一个server负责监听指定的端口，之后处理不同的请求，只不过加上的很多控制，k8s项目由那么多大牛构建，作为参考学习，看一下各个组件的源码，想必也是很有帮助的。 这里分析的是k8s v1.0.0 版本的代码,commit id 为 cd821444dcf3。 main函数的代码位于./kubernetes/cmd/kube-apiserver：</p>
<pre><code>func main() {
    runtime.GOMAXPROCS(runtime.NumCPU())
    rand.Seed(time.Now().UTC().UnixNano())

    s := app.NewAPIServer()
    s.AddFlags(pflag.CommandLine)

    util.InitFlags()
    util.InitLogs()
    defer util.FlushLogs()

    verflag.PrintAndExitIfRequested()

    if err := s.Run(pflag.CommandLine.Args()); err != nil {
        fmt.Fprintf(os.Stderr, &quot;%v\n&quot;, err)
        os.Exit(1)
    }
}
</code></pre>
<p>这一部分主要是进行一些初始化的设置，启动一个apiserver实例，再将其run起来。初始化的各种细节参数暂时不做重点分析，主要关注一下，<code>app.NewAPIServer()</code>以及<code>s.AddFlags(pflag.CommandLine)</code> 两个函数，New一个apiserver的时候会放入许多默认的初始化参数：</p>
<pre><code>func NewAPIServer() *APIServer {
    s := APIServer{
        InsecurePort:           8080,
        InsecureBindAddress:    util.IP(net.ParseIP(&quot;127.0.0.1&quot;)),
        BindAddress:            util.IP(net.ParseIP(&quot;0.0.0.0&quot;)),
        SecurePort:             6443,
        APIRate:                10.0,
        APIBurst:               200,
        APIPrefix:              &quot;/api&quot;,
        EventTTL:               1 * time.Hour,
        AuthorizationMode:      &quot;AlwaysAllow&quot;,
        AdmissionControl:       &quot;AlwaysAdmit&quot;,
        EtcdPathPrefix:         master.DefaultEtcdPathPrefix,
        EnableLogsSupport:      true,
        MasterServiceNamespace: api.NamespaceDefault,
        ClusterName:            &quot;kubernetes&quot;,
        CertDirectory:          &quot;/var/run/kubernetes&quot;,

        RuntimeConfig: make(util.ConfigurationMap),
        KubeletConfig: client.KubeletConfig{
            Port:        ports.KubeletPort,
            EnableHttps: true,
            HTTPTimeout: time.Duration(5) * time.Second,
        },
    }

    return &amp;s
}
</code></pre>
<p>可以看到insecure的端口，以及一些默认的监听端口，还有默认的证书存放位置等等，都是一些比较重要的信息。 启动时候的全部参数通过<code>s.AddFlags(pflag.CommandLine)</code>这个函数传入，里面包括了apiserver启动时候的全部参数，这个使用的是<code>&quot;github.com/spf13/pflag&quot;</code>这个库，可以具体查看每个相关参数的含义以及初始值。把这些参数的含义弄清，启动的时候把对应的合适的值填进去，作为apiserver的基本使用就基本没问题了。 之后负责启动的操作都是在run函数中执行，前面初始化的具体细节暂不做分析，这里着重关注一下两部分，一个是master实例的生成：</p>
<pre><code>config := &amp;master.Config{
    EtcdHelper:             helper,
    EventTTL:               s.EventTTL,
    KubeletClient:          kubeletClient,
    ServiceClusterIPRange:  &amp;n,
    EnableCoreControllers:  true,
    EnableLogsSupport:      s.EnableLogsSupport,
    EnableUISupport:        true,
    EnableSwaggerSupport:   true,
    EnableProfiling:        s.EnableProfiling,
    EnableIndex:            true,
    APIPrefix:              s.APIPrefix,
    CorsAllowedOriginList:  s.CorsAllowedOriginList,
    ReadWritePort:          s.SecurePort,
    PublicAddress:          net.IP(s.AdvertiseAddress),
    Authenticator:          authenticator,
    SupportsBasicAuth:      len(s.BasicAuthFile) &gt; 0,
    Authorizer:             authorizer,
    AdmissionControl:       admissionController,
    EnableV1Beta3:          enableV1beta3,
    DisableV1:              disableV1,
    MasterServiceNamespace: s.MasterServiceNamespace,
    ClusterName:            s.ClusterName,
    ExternalHost:           s.ExternalHost,
    MinRequestTimeout:      s.MinRequestTimeout,
    SSHUser:                s.SSHUser,
    SSHKeyfile:             s.SSHKeyfile,
    InstallSSHKey:          installSSH,
    ServiceNodePortRange:   s.ServiceNodePortRange,
}
m := master.New(config)
</code></pre>
<p>这个是主要是生成master实例对象，各种api请求最后都是通过master对象来处理的。 还有一个是server启动的时候：</p>
<pre><code>if secureLocation != &quot;&quot; {
    secureServer := &amp;http.Server{
        Addr:           secureLocation,
        Handler:        apiserver.MaxInFlightLimit(sem, longRunningRE, apiserver.RecoverPanics(m.Handler)),
        ReadTimeout:    ReadWriteTimeout,
        WriteTimeout:   ReadWriteTimeout,
        MaxHeaderBytes: 1 &lt;&lt; 20,
        TLSConfig: &amp;tls.Config{
            // Change default from SSLv3 to TLSv1.0 (because of POODLE vulnerability)
            MinVersion: tls.VersionTLS10,
        },
    }

    if len(s.ClientCAFile) &gt; 0 {
        clientCAs, err := util.CertPoolFromFile(s.ClientCAFile)
        if err != nil {
            glog.Fatalf(&quot;unable to load client CA file: %v&quot;, err)
        }
        // Populate PeerCertificates in requests, but don't reject connections without certificates
        // This allows certificates to be validated by authenticators, while still allowing other auth types
        secureServer.TLSConfig.ClientAuth = tls.RequestClientCert
        // Specify allowed CAs for client certificates
        secureServer.TLSConfig.ClientCAs = clientCAs
    }

    glog.Infof(&quot;Serving securely on %s&quot;, secureLocation)
    go func() {
        defer util.HandleCrash()
        for {
            if s.TLSCertFile == &quot;&quot; &amp;&amp; s.TLSPrivateKeyFile == &quot;&quot; {
                s.TLSCertFile = path.Join(s.CertDirectory, &quot;apiserver.crt&quot;)
                s.TLSPrivateKeyFile = path.Join(s.CertDirectory, &quot;apiserver.key&quot;)
                // TODO (cjcullen): Is PublicAddress the right address to sign a cert with?
                alternateIPs := []net.IP{config.ServiceReadWriteIP}
                alternateDNS := []string{&quot;kubernetes.default.svc&quot;, &quot;kubernetes.default&quot;, &quot;kubernetes&quot;}
                // It would be nice to set a fqdn subject alt name, but only the kubelets know, the apiserver is clueless
                // alternateDNS = append(alternateDNS, &quot;kubernetes.default.svc.CLUSTER.DNS.NAME&quot;)
                if err := util.GenerateSelfSignedCert(config.PublicAddress.String(), s.TLSCertFile, s.TLSPrivateKeyFile, alternateIPs, alternateDNS); err != nil {
                    glog.Errorf(&quot;Unable to generate self signed cert: %v&quot;, err)
                } else {
                    glog.Infof(&quot;Using self-signed cert (%s, %s)&quot;, s.TLSCertFile, s.TLSPrivateKeyFile)
                }
            }
            // err == systemd.SdNotifyNoSocket when not running on a systemd system
            if err := systemd.SdNotify(&quot;READY=1\n&quot;); err != nil &amp;&amp; err != systemd.SdNotifyNoSocket {
                glog.Errorf(&quot;Unable to send systemd daemon sucessful start message: %v\n&quot;, err)
            }
            if err := secureServer.ListenAndServeTLS(s.TLSCertFile, s.TLSPrivateKeyFile); err != nil {
                glog.Errorf(&quot;Unable to listen for secure (%v); will try again.&quot;, err)
            }
            time.Sleep(15 * time.Second)
        }
    }()
}
http := &amp;http.Server{
    Addr:           insecureLocation,
    Handler:        apiserver.RecoverPanics(m.InsecureHandler),
    ReadTimeout:    ReadWriteTimeout,
    WriteTimeout:   ReadWriteTimeout,
    MaxHeaderBytes: 1 &lt;&lt; 20,
}
if secureLocation == &quot;&quot; {
    // err == systemd.SdNotifyNoSocket when not running on a systemd system
    if err := systemd.SdNotify(&quot;READY=1\n&quot;); err != nil &amp;&amp; err != systemd.SdNotifyNoSocket {
     glog.Errorf(&quot;Unable to send systemd daemon sucessful start message: %v\n&quot;, err)
    }
}
glog.Infof(&quot;Serving insecurely on %s&quot;, insecureLocation)
glog.Fatal(http.ListenAndServe())
</code></pre>
<p>大致看一下这部分代码，首先是生成一个http.Server对象<code>secureServer</code>，设置好相关的启动参数，之后会新启一个goroutine，如果有ca文件，说明要使用https的方式，就把ca文件也一并加载进来，之后在新的goroutine中通过<code>secureServer.ListenAndServeTLS</code>启动secureserver，使用https的方式来监听指定的secure端口。 之后还会生成一个<code>http.Server</code>实例 http，这个就是采用insecure的方式，最后通过<code>http.ListenAndServe()</code>来启动。 对比两种启动方式，可以看到，它们加载的handler都来自与之前生成的master实例m，一个是<code>m.Handler</code>，另一个是<code>m.InsecureHandler</code>。采用<code>m.Handler</code>的时候会多一些额外的处理，这个暂不分析，总是这个Handler中存放的就是这个server去进行处理的各种路由和对应的实现方式。</p>
<h2 id="api认证部分的实现"><strong>api认证部分的实现</strong></h2>
<p>在上面提到的run函数中，可以找到认证组件的实现：</p>
<pre><code>authenticator, err := apiserver.NewAuthenticator(s.BasicAuthFile, s.ClientCAFile, s.TokenAuthFile, s.ServiceAccountKeyFile, s.ServiceAccountLookup, helper)
</code></pre>
<p>之后在生成master实例的时候，这个认证器<code>authenticator</code>会作为Master实例的初始参数传入：</p>
<pre><code>config := &amp;master.Config{
......
    Authenticator:          authenticator,
    ......
}
m := master.New(config)
</code></pre>
<p>这几个参数的使用也是之前issue里提到的问题比较多的地方，下面大致了解一下生成认证器的这几个参数，具体的使用在后面再进行具体的说明。</p>
<ul>
<li>
<p>s.BasicAuthFile:指定basicauthfile文件所在的位置，当这个参数不为空的时候，会开启basicauth的认证方式，这是一个.csv文件，三列分别是password,username,useruid。</p>
</li>
<li>
<p>s.ClientCAFile：用于给客户端签名的根证书，当这个参数不为空的时候，会启动https的认证方式，会通过这个根证书对客户端的证书进行身份认证。</p>
</li>
<li>
<p>s.TokenAuthFile：用于指定token文件所在的位置，当这个参数不为空的时候，会采用token的认证方式，token文件也是csv的格式，三列分别是&quot;token,username,useruid&rdquo;。</p>
</li>
<li>
<p>s.ServiceAccountKeyFile：当不为空的时候，采用ServiceAccount的认证方式，这个其实是一个公钥密钥。注释里说要包含：PEM-encoded x509 RSA private or public key，发送过来的信息是在客户端使用对应的私钥加密过的，服务端使用指定的公钥来解密信息。</p>
</li>
<li>
<p>s.ServiceAccountLookup：这个参数值一个bool值，默认为false，如果为true的话，就会从etcd中取出对应的ServiceAccount与传过来的信息进行对比验证，反之则不会。</p>
</li>
<li>
<p>helper：这是一个用于与etcd交互的客户端实例，具体生成过程这里不进行具体分析。</p>
</li>
</ul>
<p>下面结合认证器的具体生成过程对这些参数的使用进行具体分析，先总体看一下认证器部分的代码结构：</p>
<pre><code>func NewAuthenticator(basicAuthFile, clientCAFile, tokenFile, serviceAccountKeyFile string, serviceAccountLookup bool, helper tools.EtcdHelper) (authenticator.Request, error) {
    var authenticators []authenticator.Request

    if len(basicAuthFile) &gt; 0 {
        basicAuth, err := newAuthenticatorFromBasicAuthFile(basicAuthFile)
        if err != nil {
            return nil, err
        }
        authenticators = append(authenticators, basicAuth)
    }

    if len(clientCAFile) &gt; 0 {
        certAuth, err := newAuthenticatorFromClientCAFile(clientCAFile)
        if err != nil {
            return nil, err
        }
        authenticators = append(authenticators, certAuth)
    }

    if len(tokenFile) &gt; 0 {
        tokenAuth, err := newAuthenticatorFromTokenFile(tokenFile)
        if err != nil {
            return nil, err
        }
        authenticators = append(authenticators, tokenAuth)
    }

    if len(serviceAccountKeyFile) &gt; 0 {
        serviceAccountAuth, err := newServiceAccountAuthenticator(serviceAccountKeyFile, serviceAccountLookup, helper)
        if err != nil {
            return nil, err
        }
        authenticators = append(authenticators, serviceAccountAuth)
    }
    fmt.Println(&quot;the length of authticator:&quot;, len(authenticators))
    switch len(authenticators) {
    case 0:
        return nil, nil
    case 1:
        return authenticators[0], nil
    default:
        return union.New(authenticators...), nil
    }
}
</code></pre>
<p>结合上面的分析，这部分的代码结构就比较清楚了，返回的结果是一个<code>authenticator.Request</code>对象数组，每一个元素都是一个认证器，根据传入的参数是否为空来判断最后要生成多少个认证器，最后的union.New函数实际上返回的就是一个authenticator.Request数组：</p>
<pre><code>// unionAuthRequestHandler authenticates requests using a chain of authenticator.Requests
type unionAuthRequestHandler []authenticator.Request

// New returns a request authenticator that validates credentials using a chain of authenticator.Request objects
func New(authRequestHandlers ...authenticator.Request) authenticator.Request {
    return unionAuthRequestHandler(authRequestHandlers)
}
</code></pre>
<p>我们可以看一下authenticator.Request接口的实现：</p>
<pre><code>// Request attempts to extract authentication information from a request and returns
// information about the current user and true if successful, false if not successful,
// or an error if the request could not be checked.
type Request interface {
    AuthenticateRequest(req *http.Request) (user.Info, bool, error)
}
</code></pre>
<p>其中的方法 <code>AuthenticateRequest</code>的主要功能就是把userinfo从request中提取出来，并返回是否认证成功，以及对应的错误信息。</p>
<h2 id="生成带有认证器的handler"><strong>生成带有认证器的handler</strong></h2>
<p>下面我们直接跳到对于api请求的认证部分，看一下当某个请求过来的时候，apiserver是如何对其进行认证的，具体代码在/pkg/master/master.go的<code>func (m *Master) init(c *Config)</code>函数中：</p>
<pre><code>// Install Authenticator
    if c.Authenticator != nil {
        authenticatedHandler, err := handlers.NewRequestAuthenticator(m.requestContextMapper, c.Authenticator, handlers.Unauthorized(c.SupportsBasicAuth), handler)
        if err != nil {
            glog.Fatalf(&quot;Could not initialize authenticator: %v&quot;, err)
        }
        handler = authenticatedHandler
    }   }
        handler = authenticatedHandler
    }
</code></pre>
<p>实现细节暂不讨论，从功能上讲，这一段就是对handler进行一层包装，生成一个带有认证器的handler。 其中<code>handlers.Unauthorized(c.SupportsBasicAuth)</code>函数是一个返回Unauthorized信息的函数，如果认证失败，这个函数就会被调用。 我们大致看一下NewRequestAuthenticator函数：</p>
<pre><code>func NewRequestAuthenticator(mapper api.RequestContextMapper, auth authenticator.Request, failed http.Handler, handler http.Handler) (http.Handler, error) {
    return api.NewRequestContextFilter(
        mapper,
        http.HandlerFunc(func(w http.ResponseWriter, req *http.Request) {
            user, ok, err := auth.AuthenticateRequest(req)
            if err != nil || !ok {
                if err != nil {
                    glog.Errorf(&quot;Unable to authenticate the request due to an error: %v&quot;, err)
                }
                failed.ServeHTTP(w, req)
                return
            }

            if ctx, ok := mapper.Get(req); ok {
                mapper.Update(req, api.WithUser(ctx, user))
            }

            handler.ServeHTTP(w, req)
        }),
    )
}
</code></pre>
<p>可以看到HandleFunc中调用的函数，就是要调用我们之前提到的AuthenticateRequest函数，使用其提取用户信息，判断验证是否成功，如果有错误或者认证失败，返回Unauthorized新的的函数就会被调用。结合之前的分析，我们只要把每种认证器的AuthenticateRequest函数分析一下，就可以了解认证操作的具体实现过程了。</p>
<h2 id="每种认证操作的具体实现过程"><strong>每种认证操作的具体实现过程</strong></h2>
<p>结合上面的<code>NewAuthenticator</code>源码可以知道，最多一共有五种authenticators:即<code>basicAuth</code>、<code>certAuth</code>、<code>tokenAuth</code>、<code>serviceAccountAuth</code>，还有通过Union.New生成的<code>unionAuthRequestHandler</code>，下面我们结合每个认证器的生成过程具体看一下每个<code>authenticators</code>的<code>AuthenticateRequest</code>函数：</p>
<ul>
<li>
<p>unionAuthRequestHandler实例</p>
<pre><code>func (authHandler unionAuthRequestHandler) AuthenticateRequest(req *http.Request) (user.Info, bool, error) { 
var errlist []error for _, 
currAuthRequestHandler := range authHandler { 
info, ok, err := currAuthRequestHandler.AuthenticateRequest(req) 
if err != nil { 
        errlist = append(errlist, err) 
        continue
 }
    if ok {
        return info, true, nil
    }
}     
</code></pre>
<p>return nil, false, errors.NewAggregate(errlist) }</p>
</li>
</ul>
<p>结合之前的NewAuthenticator可以看到，当authenticators数目大于1的时候，会生成<code>unionAuthRequestHandler</code>实例，之后会遍历其中的元素，调用每一个元素的<code>AuthenticateReques</code>方法，<strong>只要其中有一种认证方式成功，最后认证就会返回true</strong>。</p>
<ul>
<li>
<p>basicAuth：bacisAuth的认证比较直接，就是把信息从.csv文件中读取出来，返回一个PasswordAuthenticator结构，其中包含一个map:<code>users map[string]*userPasswordInfo</code>,具体验证的时候，就从map中读取已有信息，比较用户名和密码，可以看出这种认证方式确实比较基础，仅仅做了基本的认证。</p>
<pre><code>func newAuthenticatorFromBasicAuthFile(basicAuthFile string) (authenticator.Request, error) {
</code></pre>
<p>basicAuthenticator, err := passwordfile.NewCSV(basicAuthFile) if err != nil { return nil, err }<br>
return basicauth.New(basicAuthenticator), nil} 首先会生成一个basicAuthenticator实例（PasswordAuthenticator对象），之后会将这个对象转化为Authenticator实例，里面包含authenticator.Password接口，PasswordAuthenticator实现了这个接口。</p>
<pre><code>type Authenticator struct { auth authenticator.Password }
</code></pre>
<p>具体的AuthenticateRequest的调用代码比较简单：</p>
<pre><code>func (a *Authenticator) AuthenticateRequest(req *http.Request) (user.Info, bool, error) { 
</code></pre>
<p>auth := strings.TrimSpace(req.Header.Get(&ldquo;Authorization&rdquo;)) if auth == &quot;&rdquo; { return nil, false, nil } parts := strings.Split(auth, &quot; &ldquo;) if len(parts) &lt; 2 || strings.ToLower(parts[0]) != &ldquo;basic&rdquo; { return nil, false, nil }</p>
<pre><code>payload, err := base64.StdEncoding.DecodeString(parts[1])
if err != nil {
    return nil, false, err
}
    
pair := strings.SplitN(string(payload), &quot;:&quot;, 2)
if len(pair) != 2 {
    return nil, false, errors.New(&quot;malformed basic auth header&quot;)
}
username := pair[0]
password := pair[1]
return a.auth.AuthenticatePassword(username, password)}
</code></pre>
<p>主要就是从request的Header中提取出Authorization字段的信息，用basic作为分隔，之后根据<code>:</code>作为分隔，提取出用户名和密码，调用AuthenticatePassword进行检验。这里的a.auth是之前传过来的PasswordAuthenticator对象，可以看下具体的这对象的AuthenticatePassword的实现：</p>
<pre><code>func (a *PasswordAuthenticator) AuthenticatePassword(username, password string) (user.Info, bool, error) { user, ok := a.users[username] if !ok { return nil, false, nil } if user.password != password { return nil, false, nil } return user.info, true, nil }
</code></pre>
<p>就是根据username把info从map中提取出来进行检验，比较简单。</p>
</li>
<li>
<p>certAuth：这里首先要声明一点， **https仅仅是认证方式的一种，secureport可以是https的也可以不是https的，不要把这两个弄混。**关于golang中https的使用的基本内容以及相关证书的生成可以参考<a href="http://wangzhezhe.github.io/blog/2015/08/05/httpsandgolang/">之前这个文章</a>。 ca文件指定了之后，说明要使用https的方式，这里是cafile是给客户端证书签名的根证书，用于https握手的时候对客户端进行身份认证。正常情况下还要指定服务端的.key和.crt文件，这里默认的就是使用双向认证的方式，在服务端启动的时候，要把对应的证书也加进去，分别用到的是<code>tls-cert-file</code>以及<code>tls-private-key-file</code>这个两个参数，如果这两个参数没指定的话，证书就会使用自签名的方式被自动生成，放在<code>CertDirectory: &quot;/var/run/kubernetes&quot;</code>目录下。 这里具体验证的操作使用的是包含x509验证对象的AuthenticateRequest函数（./plugin/pkg/auth/authenticator/request/x509/x509.go），遵循的也是通常的https认证原理，具体细节不在此讨论。 使用ca认证的时候，只要是ca签名过的证书都可以通过验证，这个时候ca的安全性就比较重要了，在某些使用场景中，证书应该如何分发问题可能是需要考虑的。</p>
</li>
<li>
<p>tokenAuth：是用token的方式，具体代码的结构与basic auth file的方式比较类似，代码不再赘述，主要功能是先从指定的.csv文件中把信息加载进来，存在服务端TokenAuthenticator实例的一个tokens的map中<code>tokens map[string]*user.DefaultInfo</code>，之后用户信息发送过来，会从Authorization中提取出携带token值，只不过这里标记token的关键字使用的是&quot;bearer&rdquo;，把token值提取出来之后，进行对比，看是否ok。</p>
</li>
<li>
<p>serviceAccountAuth：saAuth实际上是token auth的变形，这里用到的是jwt(json web token)来进行具体的操作，具体的功能可以参考这个<a href="http://www.sel.zju.edu.cn/?p=588">文章</a>，本质上来说，saAuth也是一个token认证，只不过这个token是把一些信息加密（签名）之后生成的。大致介绍一下jwt，具体格式可以参考<a href="http://haomou.net/2014/08/13/2014_web_token/">这个文章</a>这里从实现的角度进行一些分析:</p>
<pre><code>func newServiceAccountAuthenticator(keyfile string, lookup bool, helper tools.EtcdHelper) (authenticator.Request, error) { publicKey, err := serviceaccount.ReadPublicKey(keyfile) if err != nil { return nil, err }
    
var serviceAccountGetter serviceaccount.ServiceAccountTokenGetter
if lookup {
    // If we need to look up service accounts and tokens,
    // go directly to etcd to avoid recursive auth insanity
    serviceAccountGetter = serviceaccount.NewGetterFromEtcdHelper(helper)
}
    
tokenAuthenticator := serviceaccount.JWTTokenAuthenticator([]*rsa.PublicKey{publicKey}, lookup, serviceAccountGetter)
return bearertoken.New(tokenAuthenticator), nil 
}
</code></pre>
<p>可以看到，首先将publickey提取出来，之后如果lookup参数为true，会根据etcdhelper生成一个serviceAccountGetter,否则使用默认的serviceAccountGetter,用来从etcd中取具体的sa和secret，secret可以理解为某些敏感信息：</p>
<pre><code>type ServiceAccountTokenGetter interface { GetServiceAccount(namespace, name string) (*api.ServiceAccount, error) GetSecret(namespace, name string) (*api.Secret, error) }
</code></pre>
<p>我们先看最后一部分<code>bearertoken.New(tokenAuthenticator)</code>,返回的Authenticator结构的AuthenticateRequest方法就和tokenauth中的一样，从Authorization字段中提取出bearer token，之后使用接口中的方法<code>a.auth.AuthenticateToken(token)</code>进行验证，这里实际执行AuthenticateToken方法的是tokenAuthenticator对象（jwtTokenAuthenticator实例），<code>func (j *jwtTokenAuthenticator) AuthenticateToken(token string)</code>函数代码较长，就不在赘述，其主要的功能是使用之前提取出来的公钥密钥对信息进行解密，得到<code>parsedToken</code>:</p>
<pre><code>type Token struct { 
Raw string // The raw token. Populated when you Parse a token 
Method    SigningMethod // The signing method used or to be used 
Header     map[string]interface{} // The first segment of the token       
Claims       map[string]interface{} // The second segment of the token     
Signature string // The third segment of the token. Populated when you Parse a token 
Valid bool // Is the token valid? Populated when you Parse/Verify a token }
</code></pre>
<p>之后提取出其中的Claims信息并进行检验，看是否符合要求，如果look up字段为true的话，就会根据标记在Claims中的namespace ，secretName ，serviceAccountName , 利用之前生成的ServiceAccountTokenGetter从etcd中取出已设置好的serviceaccount以及secret来进行身份验证，验证通过之后会返回user信息。 ServiceAccount的相关部分代码还在不断完善中，这里只分析了大概逻辑，相比其他方式serviceaccount还是挺好使用的，相当于是token的升级版，由于信息加密的原因，比仅仅使用token安全了不少，下面是参考k8相关代码生成的使用serviceacount方式发送api的方式，实际使用中，后面的发送api的部分直接使用源码中自己的kubectl，设置好对应的BearerToken字段即可：</p>
<pre><code>package main
    
    
import ( //&quot;crypto/rsa&quot; &quot;crypto/tls&quot; &quot;fmt&quot; &quot;github.com/GoogleCloudPlatform/kubernetes/pkg/serviceaccount&quot; &quot;github.com/dgrijalva/jwt-go&quot; &quot;io/ioutil&quot; &quot;net/http&quot; )
    
const ( test1 = &quot;test1&quot; test2 = &quot;test2&quot; )
    
func main() {
    
// Create the token
token := jwt.New(jwt.SigningMethodRS256)
// Set some claims
token.Claims[test1] = &quot;zjusel&quot;
token.Claims[test2] = &quot;zjusel&quot;
    
// Sign and get the complete encoded token as a string
    
//客户端用私钥进行加密 服务端用公钥进行解密
privateKey, err := serviceaccount.ReadPrivateKey(&quot;sa.key&quot;)
    
fmt.Println(privateKey)
if err != nil {
    fmt.Println(err.Error())
    return
}
    
tokenString, err := token.SignedString(privateKey)
if err != nil {
    fmt.Println(err.Error())
}
fmt.Println(&quot;token string: &quot;, tokenString)
    
tr := &amp;http.Transport{
    TLSClientConfig: &amp;tls.Config{
        InsecureSkipVerify: true},
    DisableCompression: true,
}
    
client := &amp;http.Client{Transport: tr}
    
url := &quot;https://10.10.105.34:8081/api/v1/nodes&quot;
    
reqest, err := http.NewRequest(&quot;GET&quot;, url, nil)
reqest.Header.Set(&quot;Content-Type&quot;, &quot;application/x-www-form-urlencoded&quot;)
reqest.Header.Set(&quot;Authorization&quot;, &quot;bearer &quot;+tokenString)
resp, err := client.Do(reqest)
    
if err != nil {
    fmt.Println(err.Error())
    return
}
    
body, _ := ioutil.ReadAll(resp.Body)
fmt.Println(string(body))
    
}
</code></pre>
</li>
</ul>
<h2 id="总结"><strong>总结</strong></h2>
<p>通过上面的分析，相信对kube-apiserver启动时候的身份验证部分的参数已经可以做到“心中有数”，即使有不清楚的地方，至少也可以做到按图索骥，从源码的角度分析参数应该如何设置，在实际使用中可以根据不同的场景使用合适的方式进行认证。 [simple-author-box]</p>

                        </div>
                        
                        
                        
                        
                        
                        <div id="SOHUCS"></div>
                        <script charset="utf-8" type="text/javascript" src="https://cy-cdn.kuaizhan.com/upload/changyan.js" ></script>
                        <script type="text/javascript">
                          window.changyan.api.config({
                          appid: 'cyuX8hDAj',
                          conf: 'prod_4e1f40d37469ca7d81688963c063f0f7'
                          });
                        </script>

                    </div>
                    

                    

                    

                    <div class="col-md-3">

                        

                        

<div class="panel panel-default sidebar-menu">

    <div class="panel-heading">
      <h3 class="panel-title">搜索栏</h3>
      
    </div>

    <div class="panel-body">
        
        <div class="search" id="search">
            <div class="input-group">
                <input type="text" name="q" class="form-control" placeholder="请输入文章标题或摘要..." id="search-key">
                <input type="hidden" name="sitesearch" value="https://Rachel-Shao.github.io/">
                <span class="input-group-btn">
                    <button type="submit" class="btn btn-template-main" onclick="search()"><i class="fas fa-search"></i></button>
                </span>
            </div>
            <h1 id="search-tip" style="color: red;text-align: center;display: none;font-size: medium;">搜索中，请稍后 ...</h1>
        </div>
        <script type="text/javascript">
            
            window.onload = function() {
                      document.onkeydown = function(ev) {
                        var event = ev || event
                        if (event.keyCode == 13) {
                          search()
                        }
                      }
                    }
            
            function search() {
                      key = document.getElementById("search-key").value;
                      if (key === "") {
                        
                        return;
                      }
                      document.getElementById("search-key").value = "";
                  
                      
                      document.getElementById("search-tip").innerText = "搜索中，请稍后 ...";
                      document.getElementById("search-tip").style.display = "block";
                  
                      
                      var el = document.getElementById('blog-listing-medium');
                      var childs = el.childNodes;
                      for (var i = childs.length - 1; i >= 0; i--) {
                        el.removeChild(childs[i]);
                      }
                  
                      
                      xmltext = new XMLHttpRequest;
                      xmltext.open("GET", "/index.xml", false);
                      xmltext.send();
                      resp = xmltext.responseXML;
                      items = resp.getElementsByTagName("item");
                      
                      var i = 0;
                      haveResult = false;
                      while (i < items.length) {
                        txt = items[i].getElementsByTagName("title")[0].innerHTML + items[i].getElementsByTagName("description")[0].innerHTML
                        if (txt.indexOf(key) > -1) {
                          haveResult = true;
                          title = items[i].getElementsByTagName("title")[0].innerHTML;
                          link = items[i].getElementsByTagName("link")[0].innerHTML;
                          time = items[i].getElementsByTagName("pubDate")[0].innerHTML;
                          mark = items[i].getElementsByTagName("description")[0].innerHTML;
                          addItem(title, link, time, mark)
                        }
                        i++;
                      }
                      if (!haveResult) {
                        document.getElementById("search-tip").innerText = "搜索完毕，未发现结果 ...";
                        document.getElementById("search-tip").style.display = "block";
                      }
                    }
                  
                    
                    function addItem(title, link, time, mark) {
                      document.getElementById("search-tip").style.display = "none";
                      tmpl = "<article class=\"post\" style=\"border-bottom: 1px solid #e6e6e6;\" >" +
                        "<header class=\"post-header\">" +
                        "<h1 class=\"post-title\"><a class=\"post-link\" href=\"" + link + "\" target=\"_blank\">" + title + "</a></h1>" +
                        "<div class=\"post-meta\">" +
                        " <span class=\"post-time\">" + time + "</span>" +
                        "</div>" +
                        " </header>" +
                        "<div class=\"post-content\">" +
                        "<div class=\"post-summary\">" + mark + "</div>" +
                        "<div class=\"read-more\">" +
                        "<a href=" + link + " class=\"read-more-link\" target=\"_blank\">阅读更多</a>" +
                        "</div>" +
                        " </div>" +
                        "</article>"
                      div = document.createElement("div")
                      div.innerHTML = tmpl;
                      document.getElementById('blog-listing-medium').appendChild(div)
                    }

        </script>
        
    </div>
</div>







<div class="panel panel-default sidebar-menu">

    <div class="panel-heading">
        <h3 class="panel-title">归档栏</h3>
        
    </div>

    <div class="panel-body">
        <ul class="nav nav-pills nav-stacked">
            
            
            <li>
                <a href="/categories/cloudfoundry">cloudfoundry (12)</a>
            </li>
            
            <li>
                <a href="/categories/contaienrd">contaienrd (1)</a>
            </li>
            
            <li>
                <a href="/categories/docker">docker (12)</a>
            </li>
            
            <li>
                <a href="/categories/kubernetes">kubernetes (1)</a>
            </li>
            
            <li>
                <a href="/categories/network">network (1)</a>
            </li>
            
        </ul>
    </div>

</div>








<div class="panel sidebar-menu">

    <div class="panel-heading">
        <h3 class="panel-title">标签栏</h3>
        
    </div>

    <div class="panel-body">
        <ul class="tag-cloud">
            
            
            <li>
                <a href="/tags/agent"><i class="fas fa-tags"></i> agent</a>
            </li>
            
            <li>
                <a href="/tags/apiserver"><i class="fas fa-tags"></i> apiserver</a>
            </li>
            
            <li>
                <a href="/tags/books"><i class="fas fa-tags"></i> books</a>
            </li>
            
            <li>
                <a href="/tags/bosh"><i class="fas fa-tags"></i> bosh</a>
            </li>
            
            <li>
                <a href="/tags/ccng"><i class="fas fa-tags"></i> ccng</a>
            </li>
            
            <li>
                <a href="/tags/cf-release"><i class="fas fa-tags"></i> cf-release</a>
            </li>
            
            <li>
                <a href="/tags/cgroups"><i class="fas fa-tags"></i> cgroups</a>
            </li>
            
            <li>
                <a href="/tags/cloud_controller_ng"><i class="fas fa-tags"></i> cloud_controller_ng</a>
            </li>
            
            <li>
                <a href="/tags/cloudfoundry"><i class="fas fa-tags"></i> cloudfoundry</a>
            </li>
            
            <li>
                <a href="/tags/cloudnative"><i class="fas fa-tags"></i> cloudnative</a>
            </li>
            
            <li>
                <a href="/tags/collector"><i class="fas fa-tags"></i> collector</a>
            </li>
            
            <li>
                <a href="/tags/containerd"><i class="fas fa-tags"></i> containerd</a>
            </li>
            
            <li>
                <a href="/tags/cri"><i class="fas fa-tags"></i> cri</a>
            </li>
            
            <li>
                <a href="/tags/dea"><i class="fas fa-tags"></i> dea</a>
            </li>
            
            <li>
                <a href="/tags/docker"><i class="fas fa-tags"></i> docker</a>
            </li>
            
            <li>
                <a href="/tags/docker-network"><i class="fas fa-tags"></i> docker-network</a>
            </li>
            
            <li>
                <a href="/tags/edgecomputing"><i class="fas fa-tags"></i> edgecomputing</a>
            </li>
            
            <li>
                <a href="/tags/etcd"><i class="fas fa-tags"></i> etcd</a>
            </li>
            
            <li>
                <a href="/tags/gorouter"><i class="fas fa-tags"></i> gorouter</a>
            </li>
            
            <li>
                <a href="/tags/haproxy"><i class="fas fa-tags"></i> haproxy</a>
            </li>
            
            <li>
                <a href="/tags/healthmanager"><i class="fas fa-tags"></i> healthmanager</a>
            </li>
            
            <li>
                <a href="/tags/istio"><i class="fas fa-tags"></i> istio</a>
            </li>
            
            <li>
                <a href="/tags/kubeedge"><i class="fas fa-tags"></i> kubeedge</a>
            </li>
            
            <li>
                <a href="/tags/kubelet"><i class="fas fa-tags"></i> kubelet</a>
            </li>
            
            <li>
                <a href="/tags/kubernetes"><i class="fas fa-tags"></i> kubernetes</a>
            </li>
            
            <li>
                <a href="/tags/libcontainer"><i class="fas fa-tags"></i> libcontainer</a>
            </li>
            
            <li>
                <a href="/tags/micro-service"><i class="fas fa-tags"></i> micro-service</a>
            </li>
            
            <li>
                <a href="/tags/namespace"><i class="fas fa-tags"></i> namespace</a>
            </li>
            
            <li>
                <a href="/tags/nats"><i class="fas fa-tags"></i> nats</a>
            </li>
            
            <li>
                <a href="/tags/news"><i class="fas fa-tags"></i> news</a>
            </li>
            
            <li>
                <a href="/tags/pipework"><i class="fas fa-tags"></i> pipework</a>
            </li>
            
            <li>
                <a href="/tags/pouch"><i class="fas fa-tags"></i> pouch</a>
            </li>
            
            <li>
                <a href="/tags/runc"><i class="fas fa-tags"></i> runc</a>
            </li>
            
            <li>
                <a href="/tags/runtime"><i class="fas fa-tags"></i> runtime</a>
            </li>
            
            <li>
                <a href="/tags/security"><i class="fas fa-tags"></i> security</a>
            </li>
            
            <li>
                <a href="/tags/serverless"><i class="fas fa-tags"></i> serverless</a>
            </li>
            
            <li>
                <a href="/tags/service-mesh"><i class="fas fa-tags"></i> service-mesh</a>
            </li>
            
            <li>
                <a href="/tags/syslog_aggregator"><i class="fas fa-tags"></i> syslog_aggregator</a>
            </li>
            
        </ul>
    </div>

</div>






                        

                    </div>
                    

                    

                </div>
                

            </div>
            
        </div>
        

        <footer id="footer">
    <div class="container">

        
        <div class="col-md-4 col-sm-6">
            <h4></h4>

            <p><strong>关于我们：<strong> <p>浙大SEL实验室</p><p>地址：杭州市浙大路38号曹光彪西楼405室</p><p><strong></strong>
            <a href="/contact" class="btn btn-small btn-template-main" >跳转到关于</a>

            <hr class="hidden-md hidden-lg hidden-sm">

        </div>
        
        

        <div class="col-md-4 col-sm-6">

             
            <h4>最新博客</h4>
            

            <div class="blog-entries">
                
                <div class="item same-height-row clearfix">
                    <div class="image same-height-always">
                        <a href="https://Rachel-Shao.github.io/blog/2018/11/29/kubeedge%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97%E4%B8%80%E6%80%BB%E4%BD%93%E6%9E%B6%E6%9E%84%E5%88%86%E6%9E%90/">
                          
                            <img src="/img/placeholder.png" class="img-responsive" alt="kubeedge源码分析系列一：总体架构分析">
                          
                        </a>
                    </div>
                    <div class="name same-height-always">
                        <h5><a href="https://Rachel-Shao.github.io/blog/2018/11/29/kubeedge%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97%E4%B8%80%E6%80%BB%E4%BD%93%E6%9E%B6%E6%9E%84%E5%88%86%E6%9E%90/">kubeedge源码分析系列一：总体架构分析</a></h5>
                    </div>
                </div>
                
                <div class="item same-height-row clearfix">
                    <div class="image same-height-always">
                        <a href="https://Rachel-Shao.github.io/blog/2018/10/11/knative-serving%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/">
                          
                            <img src="/img/placeholder.png" class="img-responsive" alt="knative serving开发环境搭建">
                          
                        </a>
                    </div>
                    <div class="name same-height-always">
                        <h5><a href="https://Rachel-Shao.github.io/blog/2018/10/11/knative-serving%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/">knative serving开发环境搭建</a></h5>
                    </div>
                </div>
                
                <div class="item same-height-row clearfix">
                    <div class="image same-height-always">
                        <a href="https://Rachel-Shao.github.io/blog/2018/08/05/%E4%BB%8Econtaienrd-pull%E9%95%9C%E5%83%8F%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90oci-distribution-spec/">
                          
                            <img src="/img/blogs/921/dockerarchitecture.png" class="img-responsive" alt="从contaienrd pull镜像流程分析oci distribution spec">
                          
                        </a>
                    </div>
                    <div class="name same-height-always">
                        <h5><a href="https://Rachel-Shao.github.io/blog/2018/08/05/%E4%BB%8Econtaienrd-pull%E9%95%9C%E5%83%8F%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90oci-distribution-spec/">从contaienrd pull镜像流程分析oci distribution spec</a></h5>
                    </div>
                </div>
                
            </div>

            <hr class="hidden-md hidden-lg">
             

        </div>
        

        
        <div class="col-md-4 col-sm-6">

          <h4></h4>

            <p><strong>联系我们: 
                                    <p>团队负责人：丁轶群 yiqunding@zju.edu.cn</p>
                                    <p>网站维护人：冯志凌 502361391@qq.com</p>                
    </strong>

            

            <hr class="hidden-md hidden-lg hidden-sm">

        </div>
        
        

    </div>
    
</footer>







<div id="copyright">
    <div class="container">
        <div class="col-md-12">
            
            <p class="pull-left">Copyright ©️ 2020 SEL Laboratory , ZJ University all rights reserved.</p>
            
            <p class="pull-right">
               <a href="https://bootstrapious.com/p/universal-business-e-commerce-template">Bootstrapious</a>.
              

               <a href="https://github.com/devcows/hugo-universal-theme">DevCows</a>.
            </p>
        </div>
    </div>
</div>





    </div>
    

    
<script src="//code.jquery.com/jquery-3.1.1.min.js" integrity="sha256-hVVnYaiADRTO2PzUGmuLJr8BLUSjGIZsDYGmIJLv2b8=" crossorigin="anonymous"></script>
<script src="//maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script>

<script src="//cdnjs.cloudflare.com/ajax/libs/jquery-cookie/1.4.1/jquery.cookie.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/waypoints/4.0.1/jquery.waypoints.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/Counter-Up/1.0/jquery.counterup.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/jquery-parallax/1.1.3/jquery-parallax.js"></script>

<script src="/js/front.js"></script>


<script src="/js/owl.carousel.min.js"></script>



  </body>
</html>
